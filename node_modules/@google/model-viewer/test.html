<!--
/*
 * Copyright 2018 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
-->
<!doctype html>
<html>
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <title>&lt;model-viewer&gt; Fidelity Test - Damaged Helmet HDR PMREM</title>

  <style>
    body { margin: 0; }
    model-viewer { --progress-bar-color: transparent; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script src="./node_modules/three/build/three.js"></script>
  <script>
    const {canvas} = self;
    const renderer = new THREE.WebGLRenderer();
    const camera = new THREE.PerspectiveCamera();
    const scene = new THREE.Scene();
    const mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: 'red', wireframe: true }));
    const context = canvas.getContext('2d');

    let maxWidth = 0;
    let maxHeight = 0;

    const updateSize = () => {
      const width = window.innerWidth;
      const height = window.innerHeight;

      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';

      canvas.width = window.devicePixelRatio * width;
      canvas.height = window.devicePixelRatio * height;

      maxWidth = Math.max(width, maxWidth);
      maxHeight = Math.max(height, maxHeight);

      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(maxWidth, maxHeight, false);
      renderer.setViewport(0, 0, width, height);

      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    };

    const render = () => {
      const width = window.innerWidth * window.devicePixelRatio;
      const height = window.innerHeight * window.devicePixelRatio;

      renderer.render(scene, camera);
      context.drawImage(renderer.domElement, 0, 0, width, height, 0, 0, width, height);

      requestAnimationFrame(() => render());
    }

    window.addEventListener('resize', () => updateSize());

    mesh.position.set(0, 0, -3);

    scene.add(mesh);

    updateSize();
    render();
  </script>
</body>
</html>
