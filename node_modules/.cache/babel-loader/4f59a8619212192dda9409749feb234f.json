{"ast":null,"code":"/**\n * @author Prashant Sharma / spidersharma03\n * @author Ben Houston / bhouston, https://clara.io\n *\n * This class takes the cube lods(corresponding to different roughness values), and creates a single cubeUV\n * Texture. The format for a given roughness set of faces is simply::\n * +X+Y+Z\n * -X-Y-Z\n * For every roughness a mip map chain is also saved, which is essential to remove the texture artifacts due to\n * minification.\n * Right now for every face a PlaneMesh is drawn, which leads to a lot of geometry draw calls, but can be replaced\n * later by drawing a single buffer and by sending the appropriate faceIndex via vertex attributes.\n * The arrangement of the faces is fixed, as assuming this arrangement, the sampling function has been written.\n */\nimport { BackSide, CubeUVReflectionMapping, LinearFilter, LinearToneMapping, Mesh, NoBlending, OrthographicCamera, PlaneBufferGeometry, RGBEEncoding, RGBM16Encoding, Scene, ShaderMaterial, Vector2, Vector3, WebGLRenderTarget } from \"../../../build/three.module.js\";\n\nvar PMREMCubeUVPacker = function () {\n  var camera = new OrthographicCamera();\n  var scene = new Scene();\n  var shader = getShader();\n\n  var PMREMCubeUVPacker = function (cubeTextureLods) {\n    this.cubeLods = cubeTextureLods;\n    var size = cubeTextureLods[0].width * 4;\n    var sourceTexture = cubeTextureLods[0].texture;\n    var params = {\n      format: sourceTexture.format,\n      magFilter: sourceTexture.magFilter,\n      minFilter: sourceTexture.minFilter,\n      type: sourceTexture.type,\n      generateMipmaps: sourceTexture.generateMipmaps,\n      anisotropy: sourceTexture.anisotropy,\n      encoding: sourceTexture.encoding === RGBEEncoding ? RGBM16Encoding : sourceTexture.encoding\n    };\n\n    if (params.encoding === RGBM16Encoding) {\n      params.magFilter = LinearFilter;\n      params.minFilter = LinearFilter;\n    }\n\n    this.CubeUVRenderTarget = new WebGLRenderTarget(size, size, params);\n    this.CubeUVRenderTarget.texture.name = \"PMREMCubeUVPacker.cubeUv\";\n    this.CubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n    this.objects = [];\n    var geometry = new PlaneBufferGeometry(1, 1);\n    var faceOffsets = [];\n    faceOffsets.push(new Vector2(0, 0));\n    faceOffsets.push(new Vector2(1, 0));\n    faceOffsets.push(new Vector2(2, 0));\n    faceOffsets.push(new Vector2(0, 1));\n    faceOffsets.push(new Vector2(1, 1));\n    faceOffsets.push(new Vector2(2, 1));\n    var textureResolution = size;\n    size = cubeTextureLods[0].width;\n    var offset2 = 0;\n    var c = 4.0;\n    this.numLods = Math.log(cubeTextureLods[0].width) / Math.log(2) - 2; // IE11 doesn't support Math.log2\n\n    for (var i = 0; i < this.numLods; i++) {\n      var offset1 = (textureResolution - textureResolution / c) * 0.5;\n      if (size > 16) c *= 2;\n      var nMips = size > 16 ? 6 : 1;\n      var mipOffsetX = 0;\n      var mipOffsetY = 0;\n      var mipSize = size;\n\n      for (var j = 0; j < nMips; j++) {\n        // Mip Maps\n        for (var k = 0; k < 6; k++) {\n          // 6 Cube Faces\n          var material = shader.clone();\n          material.uniforms['envMap'].value = this.cubeLods[i].texture;\n          material.envMap = this.cubeLods[i].texture;\n          material.uniforms['faceIndex'].value = k;\n          material.uniforms['mapSize'].value = mipSize;\n          var planeMesh = new Mesh(geometry, material);\n          planeMesh.position.x = faceOffsets[k].x * mipSize - offset1 + mipOffsetX;\n          planeMesh.position.y = faceOffsets[k].y * mipSize - offset1 + offset2 + mipOffsetY;\n          planeMesh.material.side = BackSide;\n          planeMesh.scale.setScalar(mipSize);\n          this.objects.push(planeMesh);\n        }\n\n        mipOffsetY += 1.75 * mipSize;\n        mipOffsetX += 1.25 * mipSize;\n        mipSize /= 2;\n      }\n\n      offset2 += 2 * size;\n      if (size > 16) size /= 2;\n    }\n  };\n\n  PMREMCubeUVPacker.prototype = {\n    constructor: PMREMCubeUVPacker,\n    update: function (renderer) {\n      var size = this.cubeLods[0].width * 4; // top and bottom are swapped for some reason?\n\n      camera.left = -size * 0.5;\n      camera.right = size * 0.5;\n      camera.top = -size * 0.5;\n      camera.bottom = size * 0.5;\n      camera.near = 0;\n      camera.far = 1;\n      camera.updateProjectionMatrix();\n\n      for (var i = 0; i < this.objects.length; i++) {\n        scene.add(this.objects[i]);\n      }\n\n      var gammaInput = renderer.gammaInput;\n      var gammaOutput = renderer.gammaOutput;\n      var toneMapping = renderer.toneMapping;\n      var toneMappingExposure = renderer.toneMappingExposure;\n      var currentRenderTarget = renderer.getRenderTarget();\n      renderer.gammaInput = false;\n      renderer.gammaOutput = false;\n      renderer.toneMapping = LinearToneMapping;\n      renderer.toneMappingExposure = 1.0;\n      renderer.setRenderTarget(this.CubeUVRenderTarget);\n      renderer.render(scene, camera);\n      renderer.setRenderTarget(currentRenderTarget);\n      renderer.toneMapping = toneMapping;\n      renderer.toneMappingExposure = toneMappingExposure;\n      renderer.gammaInput = gammaInput;\n      renderer.gammaOutput = gammaOutput;\n\n      for (var i = 0; i < this.objects.length; i++) {\n        scene.remove(this.objects[i]);\n      }\n    },\n    dispose: function () {\n      for (var i = 0, l = this.objects.length; i < l; i++) {\n        this.objects[i].material.dispose();\n      }\n\n      this.objects[0].geometry.dispose();\n    }\n  };\n\n  function getShader() {\n    var shaderMaterial = new ShaderMaterial({\n      uniforms: {\n        \"faceIndex\": {\n          value: 0\n        },\n        \"mapSize\": {\n          value: 0\n        },\n        \"envMap\": {\n          value: null\n        },\n        \"testColor\": {\n          value: new Vector3(1, 1, 1)\n        }\n      },\n      vertexShader: \"precision highp float;\\\n        varying vec2 vUv;\\\n        void main() {\\\n          vUv = uv;\\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\n        }\",\n      fragmentShader: \"precision highp float;\\\n        varying vec2 vUv;\\\n        uniform samplerCube envMap;\\\n        uniform float mapSize;\\\n        uniform vec3 testColor;\\\n        uniform int faceIndex;\\\n        \\\n        void main() {\\\n          vec3 sampleDirection;\\\n          vec2 uv = vUv;\\\n          uv = uv * 2.0 - 1.0;\\\n          uv.y *= -1.0;\\\n          if(faceIndex == 0) {\\\n            sampleDirection = normalize(vec3(1.0, uv.y, -uv.x));\\\n          } else if(faceIndex == 1) {\\\n            sampleDirection = normalize(vec3(uv.x, 1.0, uv.y));\\\n          } else if(faceIndex == 2) {\\\n            sampleDirection = normalize(vec3(uv.x, uv.y, 1.0));\\\n          } else if(faceIndex == 3) {\\\n            sampleDirection = normalize(vec3(-1.0, uv.y, uv.x));\\\n          } else if(faceIndex == 4) {\\\n            sampleDirection = normalize(vec3(uv.x, -1.0, -uv.y));\\\n          } else {\\\n            sampleDirection = normalize(vec3(-uv.x, uv.y, -1.0));\\\n          }\\\n          vec4 color = envMapTexelToLinear( textureCube( envMap, sampleDirection ) );\\\n          gl_FragColor = linearToOutputTexel( color );\\\n        }\",\n      blending: NoBlending\n    });\n    shaderMaterial.type = 'PMREMCubeUVPacker';\n    return shaderMaterial;\n  }\n\n  return PMREMCubeUVPacker;\n}();\n\nexport { PMREMCubeUVPacker };","map":null,"metadata":{},"sourceType":"module"}