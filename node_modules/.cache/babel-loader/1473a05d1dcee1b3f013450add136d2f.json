{"ast":null,"code":"import _slicedToArray from \"/Users/julianwildmann/Documents/01_Studium/LMU/04_Master_Thesis/Repository/online-shop/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/*\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { property } from 'lit-element';\nimport { Spherical } from 'three';\nimport { deserializeAngleToDeg, deserializeSpherical } from '../conversions.js';\nimport { $ariaLabel, $needsRender, $onModelLoad, $onResize, $onUserModelOrbit, $scene, $tick } from '../model-viewer-base.js';\nimport { SmoothControls } from '../three-components/SmoothControls.js';\nconst InteractionPromptStrategy = {\n  AUTO: 'auto',\n  WHEN_FOCUSED: 'when-focused'\n};\nexport const DEFAULT_CAMERA_ORBIT = '0deg 75deg auto';\nconst DEFAULT_FIELD_OF_VIEW = '45deg';\nconst HALF_PI = Math.PI / 2.0;\nconst THIRD_PI = Math.PI / 3.0;\nconst QUARTER_PI = HALF_PI / 2.0;\nconst PHI = 2.0 * Math.PI;\nconst AZIMUTHAL_QUADRANT_LABELS = ['front', 'right', 'back', 'left'];\nconst POLAR_TRIENT_LABELS = ['upper-', '', 'lower-'];\nexport const DEFAULT_INTERACTION_PROMPT_THRESHOLD = 3000;\nexport const INTERACTION_PROMPT = 'Use mouse, touch or arrow keys to control the camera!';\nexport const $controls = Symbol('controls');\nexport const $promptElement = Symbol('promptElement');\nexport const $idealCameraDistance = Symbol('idealCameraDistance');\nconst $deferInteractionPrompt = Symbol('deferInteractionPrompt');\nconst $updateAria = Symbol('updateAria');\nconst $updateCamera = Symbol('updateCamera');\nconst $updateCameraOrbit = Symbol('updateCameraOrbit');\nconst $updateFieldOfView = Symbol('updateFieldOfView');\nconst $blurHandler = Symbol('blurHandler');\nconst $focusHandler = Symbol('focusHandler');\nconst $changeHandler = Symbol('changeHandler');\nconst $promptTransitionendHandler = Symbol('promptTransitionendHandler');\nconst $onBlur = Symbol('onBlur');\nconst $onFocus = Symbol('onFocus');\nconst $onChange = Symbol('onChange');\nconst $onPromptTransitionend = Symbol('onPromptTransitionend');\nconst $shouldPromptUserToInteract = Symbol('shouldPromptUserToInteract');\nconst $waitingToPromptUser = Symbol('waitingToPromptUser');\nconst $userPromptedOnce = Symbol('userPromptedOnce');\nconst $idleTime = Symbol('idleTime');\nconst $lastSpherical = Symbol('lastSpherical');\nconst $jumpCamera = Symbol('jumpCamera');\nexport const ControlsMixin = ModelViewerElement => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n\n  class ControlsModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super();\n      this.cameraControls = false;\n      this.cameraOrbit = DEFAULT_CAMERA_ORBIT;\n      this.fieldOfView = DEFAULT_FIELD_OF_VIEW;\n      this.interactionPromptThreshold = DEFAULT_INTERACTION_PROMPT_THRESHOLD;\n      this.interactionPrompt = InteractionPromptStrategy.WHEN_FOCUSED;\n      this[_a] = 0;\n      this[_b] = false;\n      this[_c] = false;\n      this[_d] = true;\n      this[_e] = null;\n      this[_f] = new Spherical();\n      this[_g] = false;\n\n      this[_h] = event => this[$onChange](event);\n\n      this[_j] = () => this[$onFocus]();\n\n      this[_k] = () => this[$onBlur]();\n\n      this[_l] = () => this[$onPromptTransitionend]();\n\n      const scene = this[$scene];\n      this[$promptElement] = this.shadowRoot.querySelector('.controls-prompt');\n      this[$controls] = new SmoothControls(scene.getCamera(), scene.canvas);\n      this[$updateCameraOrbit]();\n      this[$updateFieldOfView]();\n    }\n\n    getCameraOrbit() {\n      const _this$$lastSpherical = this[$lastSpherical],\n            theta = _this$$lastSpherical.theta,\n            phi = _this$$lastSpherical.phi,\n            radius = _this$$lastSpherical.radius;\n      return {\n        theta,\n        phi,\n        radius\n      };\n    }\n\n    getFieldOfView() {\n      return this[$controls].getFieldOfView();\n    }\n\n    jumpCameraToGoal() {\n      this[$jumpCamera] = true;\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n      this[$promptTransitionendHandler]();\n      this[$promptElement].addEventListener('transitionend', this[$promptTransitionendHandler]);\n      this[$controls].addEventListener('change', this[$changeHandler]);\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this[$promptElement].removeEventListener('transitionend', this[$promptTransitionendHandler]);\n      this[$controls].removeEventListener('change', this[$changeHandler]);\n    }\n\n    updated(changedProperties) {\n      super.updated(changedProperties);\n      const controls = this[$controls];\n      const scene = this[$scene];\n\n      if (changedProperties.has('cameraControls')) {\n        if (this.cameraControls) {\n          controls.enableInteraction();\n          scene.canvas.addEventListener('focus', this[$focusHandler]);\n          scene.canvas.addEventListener('blur', this[$blurHandler]);\n        } else {\n          scene.canvas.removeEventListener('focus', this[$focusHandler]);\n          scene.canvas.removeEventListener('blur', this[$blurHandler]);\n          controls.disableInteraction();\n        }\n      }\n\n      if (changedProperties.has('interactionPrompt')) {\n        if (this.interactionPrompt === InteractionPromptStrategy.AUTO) {\n          this[$waitingToPromptUser] = true;\n        }\n      }\n\n      if (changedProperties.has('cameraOrbit')) {\n        this[$updateCameraOrbit]();\n      }\n\n      if (changedProperties.has('fieldOfView')) {\n        this[$updateFieldOfView]();\n      }\n\n      if (this[$jumpCamera] === true) {\n        this[$controls].jumpToGoal();\n        this[$jumpCamera] = false;\n      }\n    }\n\n    [(_a = $idleTime, _b = $userPromptedOnce, _c = $waitingToPromptUser, _d = $shouldPromptUserToInteract, _e = $idealCameraDistance, _f = $lastSpherical, _g = $jumpCamera, _h = $changeHandler, _j = $focusHandler, _k = $blurHandler, _l = $promptTransitionendHandler, $updateFieldOfView)]() {\n      let fov = deserializeAngleToDeg(this.fieldOfView);\n\n      if (fov == null) {\n        fov = deserializeAngleToDeg(DEFAULT_FIELD_OF_VIEW);\n      }\n\n      this[$controls].setFov(fov);\n    }\n\n    [$updateCameraOrbit]() {\n      let sphericalValues = deserializeSpherical(this.cameraOrbit);\n\n      if (sphericalValues == null) {\n        sphericalValues = deserializeSpherical(DEFAULT_CAMERA_ORBIT);\n      }\n\n      let _sphericalValues = sphericalValues,\n          _sphericalValues2 = _slicedToArray(_sphericalValues, 3),\n          theta = _sphericalValues2[0],\n          phi = _sphericalValues2[1],\n          radius = _sphericalValues2[2];\n\n      if (typeof radius === 'string') {\n        switch (radius) {\n          default:\n          case 'auto':\n            radius = this[$idealCameraDistance];\n            break;\n        }\n      }\n\n      this[$controls].setOrbit(theta, phi, radius);\n    }\n\n    [$tick](time, delta) {\n      super[$tick](time, delta);\n\n      if (this[$waitingToPromptUser]) {\n        if (this.loaded) {\n          this[$idleTime] += delta;\n        }\n\n        if (this[$idleTime] > this.interactionPromptThreshold) {\n          this[$scene].canvas.setAttribute('aria-label', INTERACTION_PROMPT); // NOTE(cdata): After notifying users that the controls are\n          // available, we flag that the user has been prompted at least\n          // once, and then effectively stop the idle timer. If the camera\n          // orbit changes after this point, the user will never be prompted\n          // again for this particular <model-element> instance:\n\n          this[$userPromptedOnce] = true;\n          this[$waitingToPromptUser] = false;\n          this[$promptElement].classList.add('visible');\n        }\n      }\n\n      this[$controls].update(time, delta);\n    }\n\n    [$deferInteractionPrompt]() {\n      // Effectively cancel the timer waiting for user interaction:\n      this[$waitingToPromptUser] = false;\n      this[$promptElement].classList.remove('visible'); // Implicitly there was some reason to defer the prompt. If the user\n      // has been prompted at least once already, we no longer need to\n      // prompt the user, although if they have never been prompted we\n      // should probably prompt them at least once just in case.\n\n      if (this[$userPromptedOnce]) {\n        this[$shouldPromptUserToInteract] = false;\n      }\n    }\n    /**\n     * Changes the camera's radius to properly frame the scene based on\n     * changes to framedHeight or fov, and maintains relative camera zoom\n     * state.\n     */\n\n\n    [$updateCamera]() {\n      const scene = this[$scene];\n      const controls = this[$controls];\n      const framedHeight = scene.framedHeight; // Make zoom sensitivity scale with model size:\n\n      const zoomSensitivity = framedHeight / 10;\n      const framedDistance = framedHeight / 2 / Math.tan(controls.getFieldOfView() / 2 * Math.PI / 180);\n      const near = framedHeight / 10.0;\n      const far = framedHeight * 10.0; // When we update the idealCameraDistance due to reframing, we want to\n      // maintain the user's zoom level (how they have changed the camera\n      // radius), which we represent here as a ratio.\n\n      const zoom = this[$idealCameraDistance] != null ? controls.getCameraSpherical().radius / this[$idealCameraDistance] : 1;\n      this[$idealCameraDistance] = framedDistance + scene.modelDepth / 2;\n      controls.updateIntrinsics(near, far, scene.aspect, zoomSensitivity); // Zooming out beyond the 'frame' doesn't serve much purpose\n      // and will only end up showing the skysphere if zoomed out enough\n\n      const minimumRadius = near + framedHeight / 2.0;\n      const maximumRadius = this[$idealCameraDistance];\n      controls.applyOptions({\n        minimumRadius,\n        maximumRadius\n      });\n      controls.setRadius(zoom * this[$idealCameraDistance]);\n      controls.setTarget(scene.target);\n      controls.jumpToGoal();\n    }\n\n    [$updateAria]() {\n      // NOTE(cdata): It is possible that we might want to record the\n      // last spherical when the label actually changed. Right now, the\n      // side-effect the current implementation is that we will only\n      // announce the first view change that occurs after the element\n      // becomes focused.\n      const _this$$lastSpherical2 = this[$lastSpherical],\n            lastTheta = _this$$lastSpherical2.theta,\n            lastPhi = _this$$lastSpherical2.phi;\n\n      const _this$$controls$getCa = this[$controls].getCameraSpherical(this[$lastSpherical]),\n            theta = _this$$controls$getCa.theta,\n            phi = _this$$controls$getCa.phi;\n\n      const rootNode = this.getRootNode(); // Only change the aria-label if <model-viewer> is currently focused:\n\n      if (rootNode != null && rootNode.activeElement === this) {\n        const lastAzimuthalQuadrant = (4 + Math.floor((lastTheta % PHI + QUARTER_PI) / HALF_PI)) % 4;\n        const azimuthalQuadrant = (4 + Math.floor((theta % PHI + QUARTER_PI) / HALF_PI)) % 4;\n        const lastPolarTrient = Math.floor(lastPhi / THIRD_PI);\n        const polarTrient = Math.floor(phi / THIRD_PI);\n\n        if (azimuthalQuadrant !== lastAzimuthalQuadrant || polarTrient !== lastPolarTrient) {\n          const canvas = this[$scene].canvas;\n          const azimuthalQuadrantLabel = AZIMUTHAL_QUADRANT_LABELS[azimuthalQuadrant];\n          const polarTrientLabel = POLAR_TRIENT_LABELS[polarTrient];\n          const ariaLabel = \"View from stage \".concat(polarTrientLabel).concat(azimuthalQuadrantLabel);\n          canvas.setAttribute('aria-label', ariaLabel);\n        }\n      }\n    }\n\n    [$onPromptTransitionend]() {\n      const svg = this[$promptElement].querySelector('svg');\n\n      if (svg == null) {\n        return;\n      } // NOTE(cdata): We need to make sure that SVG animations are paused\n      // when the prompt is not visible, otherwise we may a significant\n      // compositing cost even while the prompt is at opacity 0.\n\n\n      if (this[$promptElement].classList.contains('visible')) {\n        svg.unpauseAnimations();\n      } else {\n        svg.pauseAnimations();\n      }\n    }\n\n    [$onResize](event) {\n      super[$onResize](event);\n      this[$updateCamera]();\n    }\n\n    [$onModelLoad](event) {\n      super[$onModelLoad](event);\n      this[$updateCamera]();\n      this[$updateCameraOrbit]();\n      this[$controls].jumpToGoal();\n    }\n\n    [$onFocus]() {\n      const canvas = this[$scene].canvas; // NOTE(cdata): On every re-focus, we switch the aria-label back to\n      // the original, non-prompt label if appropriate. If the user has\n      // already interacted, they no longer need to hear the prompt.\n      // Otherwise, they will hear it again after the idle prompt threshold\n      // has been crossed.\n\n      const ariaLabel = this[$ariaLabel];\n\n      if (canvas.getAttribute('aria-label') !== ariaLabel) {\n        canvas.setAttribute('aria-label', ariaLabel);\n      } // NOTE(cdata): When focused, if the user has yet to interact with the\n      // camera controls (that is, we \"should\" prompt the user), we begin\n      // the idle timer and indicate that we are waiting for it to cross the\n      // prompt threshold:\n\n\n      if (this[$shouldPromptUserToInteract]) {\n        this[$waitingToPromptUser] = true;\n        this[$idleTime] = 0;\n      }\n    }\n\n    [$onBlur]() {\n      this[$waitingToPromptUser] = false;\n      this[$promptElement].classList.remove('visible');\n    }\n\n    [$onChange]({\n      source\n    }) {\n      if (this.interactionPrompt === InteractionPromptStrategy.WHEN_FOCUSED) {\n        this[$deferInteractionPrompt]();\n      }\n\n      this[$updateAria]();\n      this[$needsRender]();\n\n      if (source === 'user-interaction') {\n        if (this.interactionPrompt === InteractionPromptStrategy.AUTO) {\n          this[$deferInteractionPrompt]();\n        }\n\n        this[$onUserModelOrbit]();\n      }\n    }\n\n  }\n\n  __decorate([property({\n    type: Boolean,\n    attribute: 'camera-controls'\n  })], ControlsModelViewerElement.prototype, \"cameraControls\", void 0);\n\n  __decorate([property({\n    type: String,\n    attribute: 'camera-orbit',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"cameraOrbit\", void 0);\n\n  __decorate([property({\n    type: String,\n    attribute: 'field-of-view',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"fieldOfView\", void 0);\n\n  __decorate([property({\n    type: Number,\n    attribute: 'interaction-prompt-threshold'\n  })], ControlsModelViewerElement.prototype, \"interactionPromptThreshold\", void 0);\n\n  __decorate([property({\n    type: String,\n    attribute: 'interaction-prompt'\n  })], ControlsModelViewerElement.prototype, \"interactionPrompt\", void 0);\n\n  return ControlsModelViewerElement;\n};","map":null,"metadata":{},"sourceType":"module"}