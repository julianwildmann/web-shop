{"ast":null,"code":"/*\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\n\nimport { Color, DirectionalLight, HemisphereLight, Object3D, PerspectiveCamera, Scene, Vector3 } from 'three';\nimport { resolveDpr } from '../utilities.js';\nimport Model from './Model.js';\nimport StaticShadow from './StaticShadow.js';\nexport const IlluminationRole = {\n  Primary: 'primary',\n  Secondary: 'secondary'\n}; // The model is sized to the room, and if too perfect of a fit,\n// the front of the model becomes clipped by the near plane. Rather than\n// change the near plane or camera's position (if we wanted to implement a\n// visible \"room\" in the future where framing needs to be precise), we shrink\n// the room by a little bit so it's always slightly bigger than the model.\n// TODO(#527): this description has been incorrect for awhile (this is not\n// how the near plane is set) so this should probably be removed for simplicity.\n\nexport const ROOM_PADDING_SCALE = 1.01;\nconst AMBIENT_LIGHT_LOW_INTENSITY = 0.0;\nconst DIRECTIONAL_LIGHT_LOW_INTENSITY = 2.0;\nconst AMBIENT_LIGHT_HIGH_INTENSITY = 3.0;\nconst DIRECTIONAL_LIGHT_HIGH_INTENSITY = 4.0;\nconst $paused = Symbol('paused');\nconst $modelAlignmentMask = Symbol('modelAlignmentMask');\n/**\n * A THREE.Scene object that takes a Model and CanvasHTMLElement and\n * constructs a framed scene based off of the canvas dimensions.\n * Provides lights and cameras to be used in a renderer.\n */\n\nexport default class ModelScene extends Scene {\n  /**\n   * @param {ModelViewerElementBase} options.element\n   * @param {CanvasHTMLElement} options.canvas\n   * @param {number} options.width\n   * @param {number} options.height\n   * @param {Renderer} options.renderer\n   */\n  constructor({\n    canvas,\n    element,\n    width,\n    height,\n    renderer\n  }) {\n    super();\n    this[_a] = false;\n    this[_b] = new Vector3(1, 1, 1);\n    this.target = new Vector3();\n    this.framedHeight = 1;\n    this.modelDepth = 1;\n    this.isVisible = false;\n    this.isDirty = false;\n    this.name = 'ModelScene';\n    this.element = element;\n    this.canvas = canvas;\n    this.context = canvas.getContext('2d');\n    this.renderer = renderer;\n    this.exposure = 1;\n    this.model = new Model();\n    this.shadow = new StaticShadow();\n    this.light = new HemisphereLight(0xBBBBBB, 0x444444, AMBIENT_LIGHT_HIGH_INTENSITY);\n    this.light.name = 'HemisphereLight';\n    this.light.position.set(2, 4, 2); // This light is only for generating (fake) shadows\n    // and does not needed to be added to the scene.\n    // @see StaticShadow.js\n\n    this.shadowLight = new DirectionalLight(0xffffff, DIRECTIONAL_LIGHT_HIGH_INTENSITY);\n    this.shadowLight.position.set(0, 10, 0);\n    this.shadowLight.name = 'ShadowLight';\n    this.width = width;\n    this.height = height;\n    this.aspect = width / height; // These default camera values are never used, as they are reset once the\n    // model is loaded and framing is computed.\n\n    this.camera = new PerspectiveCamera(45, this.aspect, 0.1, 100);\n    this.camera.name = 'MainCamera';\n    this.activeCamera = this.camera;\n    this.pivot = new Object3D();\n    this.pivot.name = 'Pivot';\n    this.add(this.pivot);\n    this.add(this.light);\n    this.add(this.shadowLight);\n    this.pivot.add(this.model);\n    this.setSize(width, height);\n    this.background = new Color(0xffffff);\n    this.model.addEventListener('model-load', event => this.onModelLoad(event));\n  }\n\n  get paused() {\n    return this[$paused];\n  }\n\n  pause() {\n    this[$paused] = true;\n  }\n\n  resume() {\n    this[$paused] = false;\n  }\n  /**\n   * Sets the model via URL.\n   *\n   * @param {String?} source\n   * @param {Function?} progressCallback\n   */\n\n\n  async setModelSource(source, progressCallback) {\n    try {\n      await this.model.setSource(source, progressCallback);\n    } catch (e) {\n      throw new Error(\"Could not set model source to '\".concat(source, \"': \").concat(e.message));\n    }\n  }\n  /**\n   * Configures the alignment of the model within the frame based on value\n   * \"masks\". By default, the model will be aligned so that the center of its\n   * bounding box volume is in the center of the frame on all axes. In order to\n   * center the model this way, the model is translated by the delta between\n   * the world center of the bounding volume and world center of the frame.\n   *\n   * The alignment mask allows this translation to be scaled or eliminated\n   * completely for each of the three axes. So, setModelAlignment(1, 1, 1) will\n   * center the model in the frame. setModelAlignment(0, 0, 0) will align the\n   * model so that its root node origin is at [0, 0, 0] in the scene.\n   *\n   * @param {number} x\n   * @param {number} y\n   * @param {number} z\n   */\n\n\n  setModelAlignmentMask(...alignmentMaskValues) {\n    this[$modelAlignmentMask].set(...alignmentMaskValues);\n    this.alignModel();\n    this.isDirty = true;\n  }\n  /**\n   * Receives the size of the 2D canvas element to make according\n   * adjustments in the scene.\n   *\n   * @param {number} width\n   * @param {number} height\n   */\n\n\n  setSize(width, height) {\n    if (width !== this.width || height !== this.height) {\n      this.width = Math.max(width, 1);\n      this.height = Math.max(height, 1); // In practice, invocations of setSize are throttled at the element level,\n      // so no need to throttle here:\n\n      this.updateFraming();\n    }\n  }\n  /**\n   * To frame the scene, a box is fit around the model such that the X and Z\n   * dimensions (modelDepth) are the same (for Y-rotation) and the X/Y ratio is\n   * the aspect ratio of the canvas (framedHeight is the Y dimension). For\n   * non-centered models, the box is fit symmetrically about the XZ origin to\n   * keep them in frame as they are rotated. At the ideal distance, the camera's\n   * fov exactly covers the front face of this box when looking down the Z-axis.\n   */\n\n\n  updateFraming() {\n    const dpr = resolveDpr();\n    this.canvas.width = this.width * dpr;\n    this.canvas.height = this.height * dpr;\n    this.canvas.style.width = \"\".concat(this.width, \"px\");\n    this.canvas.style.height = \"\".concat(this.height, \"px\");\n    this.aspect = this.width / this.height;\n    const _this$model = this.model,\n          boundingBox = _this$model.boundingBox,\n          position = _this$model.position,\n          size = _this$model.size;\n\n    if (size.x != 0 || size.y != 0 || size.z != 0) {\n      const boxHalfX = Math.max(Math.abs(boundingBox.min.x + position.x), Math.abs(boundingBox.max.x + position.x));\n      const boxHalfZ = Math.max(Math.abs(boundingBox.min.z + position.z), Math.abs(boundingBox.max.z + position.z));\n      const modelMinY = Math.min(0, boundingBox.min.y + position.y);\n      const modelMaxY = Math.max(0, boundingBox.max.y + position.y);\n      this.target.y = this[$modelAlignmentMask].y * (modelMaxY + modelMinY) / 2;\n      const boxHalfY = Math.max(modelMaxY - this.target.y, this.target.y - modelMinY);\n      this.modelDepth = 2 * Math.max(boxHalfX, boxHalfZ);\n      this.framedHeight = ROOM_PADDING_SCALE * Math.max(2 * boxHalfY, this.modelDepth / this.aspect);\n      this.modelDepth *= ROOM_PADDING_SCALE;\n    }\n  }\n\n  configureStageLighting(intensityScale, illuminationRole) {\n    this.light.intensity = intensityScale * (illuminationRole === IlluminationRole.Primary ? AMBIENT_LIGHT_HIGH_INTENSITY : AMBIENT_LIGHT_LOW_INTENSITY);\n    this.shadowLight.intensity = intensityScale * (illuminationRole === IlluminationRole.Primary ? DIRECTIONAL_LIGHT_HIGH_INTENSITY : DIRECTIONAL_LIGHT_LOW_INTENSITY);\n    this.isDirty = true;\n  }\n  /**\n   * Returns the size of the corresponding canvas element.\n   * @return {Object}\n   */\n\n\n  getSize() {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n  /**\n   * Moves the model to be centered at the XZ origin, with Y = 0 being the floor\n   * under the model, taking into account setModelAlignmentMask(), described\n   * above.\n   */\n\n\n  alignModel() {\n    if (!this.model.hasModel() || this.model.size.length() === 0) {\n      return;\n    }\n\n    this.resetModelPose();\n    let centeredOrigin = this.model.boundingBox.getCenter(new Vector3());\n    centeredOrigin.y -= this.model.size.y / 2;\n    this.model.position.copy(centeredOrigin).multiply(this[$modelAlignmentMask]).multiplyScalar(-1);\n    this.updateFraming();\n    this.updateStaticShadow();\n  }\n\n  resetModelPose() {\n    this.model.position.set(0, 0, 0);\n    this.model.rotation.set(0, 0, 0);\n    this.model.scale.set(1, 1, 1);\n  }\n  /**\n   * Returns the current camera.\n   * @return {THREE.Camera}\n   */\n\n\n  getCamera() {\n    return this.activeCamera;\n  }\n  /**\n   * Sets the passed in camera to be used for rendering.\n   * @param {THREE.Camera}\n   */\n\n\n  setCamera(camera) {\n    this.activeCamera = camera;\n  }\n  /**\n   * Called when the model's contents have loaded, or changed.\n   */\n\n\n  onModelLoad(event) {\n    this.alignModel();\n    this.dispatchEvent({\n      type: 'model-load',\n      url: event.url\n    });\n  }\n  /**\n   * Called to update the shadow rendering when the room or model changes.\n   */\n\n\n  updateStaticShadow() {\n    if (!this.model.hasModel() || this.model.size.length() === 0) {\n      this.pivot.remove(this.shadow);\n      return;\n    } // Remove and cache the current pivot rotation so that the shadow's\n    // capture is unrotated so it can be freely rotated when applied\n    // as a texture.\n\n\n    const currentRotation = this.pivot.rotation.y;\n    this.pivot.rotation.y = 0;\n    const modelPosition = this.model.boundingBox.getCenter(new Vector3()).add(this.model.position);\n    this.shadow.scale.x = 2 * Math.abs(modelPosition.x) + this.model.size.x;\n    this.shadow.scale.z = 2 * Math.abs(modelPosition.z) + this.model.size.z;\n    this.shadow.render(this.renderer.renderer, this, this.shadowLight); // Lazily add the shadow so we're only displaying it once it has\n    // a generated texture.\n\n    this.pivot.add(this.shadow);\n    this.pivot.rotation.y = currentRotation; // TODO(#453) When we add a configurable camera target we should put the\n    // floor back at y=0 for a consistent coordinate system.\n\n    if (this[$modelAlignmentMask].y == 0) {\n      this.shadow.position.y = modelPosition.y - this.model.size.y / 2;\n    }\n  }\n\n}\n_a = $paused, _b = $modelAlignmentMask;","map":null,"metadata":{},"sourceType":"module"}