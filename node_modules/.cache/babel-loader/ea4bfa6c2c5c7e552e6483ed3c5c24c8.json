{"ast":null,"code":"/*\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { property } from 'lit-element';\nimport { $ariaLabel, $canvas, $progressTracker, $updateSource } from '../model-viewer-base.js';\nimport { CachingGLTFLoader } from '../three-components/CachingGLTFLoader.js';\nimport { debounce, deserializeUrl, throttle } from '../utilities.js';\nimport { LoadingStatusAnnouncer } from './loading/status-announcer.js';\nexport const POSTER_TRANSITION_TIME = 300;\nexport const PROGRESS_BAR_UPDATE_THRESHOLD = 100;\nconst PROGRESS_MASK_BASE_OPACITY = 0.2;\nconst ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD = 0;\nconst SPACE_KEY = 32;\nconst ENTER_KEY = 13;\nconst RevealStrategy = {\n  AUTO: 'auto',\n  INTERACTION: 'interaction'\n};\nconst PosterDismissalSource = {\n  INTERACTION: 'interaction'\n};\nconst loader = new CachingGLTFLoader();\nconst loadingStatusAnnouncer = new LoadingStatusAnnouncer();\nexport const $defaultProgressBarElement = Symbol('defaultProgressBarElement');\nexport const $defaultProgressMaskElement = Symbol('defaultProgressMaskElement');\nexport const $posterContainerElement = Symbol('posterContainerElement');\nexport const $defaultPosterElement = Symbol('defaultPosterElement');\nconst $posterDismissalSource = Symbol('posterDismissalSource');\nconst $announceModelVisibility = Symbol('announceModelVisibility');\nconst $modelIsReadyForReveal = Symbol('modelIsReadyForReveal');\nconst $shouldAttemptPreload = Symbol('shouldAttemptPreload');\nconst $shouldRevealModel = Symbol('shouldRevealModel');\nconst $showPoster = Symbol('showPoster');\nconst $hidePoster = Symbol('hidePoster');\nconst $modelIsVisible = Symbol('modelIsVisible');\nconst $preloadAttempted = Symbol('preloadAttempted');\nconst $sourceUpdated = Symbol('sourceUpdated');\nconst $updateLoadingAndVisibility = Symbol('updateLoadingAndVisibility');\nconst $updateProgressBar = Symbol('updateProgressBar');\nconst $lastReportedProgress = Symbol('lastReportedProgress');\nconst $ariaLabelCallToAction = Symbol('ariaLabelCallToAction');\nconst $clickHandler = Symbol('clickHandler');\nconst $keydownHandler = Symbol('keydownHandler');\nconst $progressHandler = Symbol('processHandler');\nconst $onClick = Symbol('onClick');\nconst $onKeydown = Symbol('onKeydown');\nconst $onProgress = Symbol('onProgress');\n/**\n * LoadingMixin implements features related to lazy loading, as well as\n * presentation details related to the pre-load / pre-render presentation of a\n * <model-viewer>\n */\n\nexport const LoadingMixin = ModelViewerElement => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n\n  class LoadingModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      /**\n       * A URL pointing to the image to use as a poster in scenarios where the\n       * <model-viewer> is not ready to reveal a rendered model to the viewer.\n       */\n\n      this.poster = null;\n      /**\n       * An enumerable attribute describing under what conditions the\n       * <model-viewer> should reveal a model to the viewer.\n       *\n       * The default value is \"auto\". The only supported alternative value as\n       * of now is \"interaction\".\n       */\n\n      this.reveal = RevealStrategy.AUTO;\n      /**\n       * If true, a configured model file will be aggressively loaded, even if\n       * the <model-viewer> is only configured to reveal upon interaction.\n       */\n\n      this.preload = false;\n      this[_a] = false;\n      this[_b] = false;\n      this[_c] = false;\n      this[_d] = 0;\n      this[_e] = null; // TODO: Add this to the shadow root as part of this mixin's\n      // implementation:\n\n      this[_f] = this.shadowRoot.querySelector('.slot.poster');\n      this[_g] = this.shadowRoot.querySelector('#default-poster');\n      this[_h] = this.shadowRoot.querySelector('#default-progress-bar > .bar');\n      this[_j] = this.shadowRoot.querySelector('#default-progress-bar > .mask');\n      this[_k] = this[$defaultPosterElement].getAttribute('aria-label');\n\n      this[_l] = () => this[$onClick]();\n\n      this[_m] = event => this[$onKeydown](event);\n\n      this[_o] = event => this[$onProgress](event);\n\n      this[_p] = debounce(visible => {\n        this.dispatchEvent(new CustomEvent('model-visibility', {\n          detail: {\n            visible\n          }\n        }));\n      }, ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD);\n      this[_q] = throttle(progress => {\n        const parentNode = this[$defaultProgressBarElement].parentNode;\n        requestAnimationFrame(() => {\n          this[$defaultProgressMaskElement].style.opacity = \"\".concat((1.0 - progress) * PROGRESS_MASK_BASE_OPACITY);\n          this[$defaultProgressBarElement].style.transform = \"scaleX(\".concat(progress, \")\");\n\n          if (progress === 0) {\n            // NOTE(cdata): We remove and re-append the progress bar in this\n            // condition so that the progress bar does not appear to\n            // transition backwards from the right when we reset to 0 (or\n            // otherwise <1) progress after having already reached 1 progress\n            // previously.\n            parentNode.removeChild(this[$defaultProgressBarElement]);\n            parentNode.appendChild(this[$defaultProgressBarElement]);\n          } // NOTE(cdata): IE11 does not properly respect the second parameter\n          // of classList.toggle, which this implementation originally used.\n          // @see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11865865/\n\n\n          if (progress === 1.0) {\n            this[$defaultProgressBarElement].classList.add('hide');\n          } else {\n            this[$defaultProgressBarElement].classList.remove('hide');\n          }\n        });\n      }, PROGRESS_BAR_UPDATE_THRESHOLD);\n    }\n    /**\n     * True if the model has finished loading. Note that a model can be\n     * loaded, but not yet be rendered.\n     */\n\n\n    get loaded() {\n      const src = this.src;\n      return super.loaded || !!(src && CachingGLTFLoader.hasFinishedLoading(src));\n    }\n    /**\n     * True if the model is visible. Visibility implies that a model has\n     * finished loading, that it has rendered at least once and that the\n     * poster is no longer obscuring it.\n     */\n\n\n    get modelIsVisible() {\n      return super.modelIsVisible && this[$modelIsVisible];\n    }\n    /**\n     * Dismisses the poster, causing the model to load and render if\n     * necessary. This is currently effectively the same as interacting with\n     * the poster via user input.\n     */\n\n\n    dismissPoster() {\n      this[$posterDismissalSource] = PosterDismissalSource.INTERACTION;\n      this.requestUpdate();\n    }\n\n    connectedCallback() {\n      super.connectedCallback(); // Fired when a user first clicks the model element. Used to\n      // change the visibility of a poster image, or start loading\n      // a model.\n\n      this[$posterContainerElement].addEventListener('click', this[$clickHandler]);\n      this[$posterContainerElement].addEventListener('keydown', this[$keydownHandler]);\n      this[$progressTracker].addEventListener('progress', this[$progressHandler]);\n      loadingStatusAnnouncer.registerInstance(this);\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this[$posterContainerElement].removeEventListener('click', this[$clickHandler]);\n      this[$posterContainerElement].removeEventListener('keydown', this[$keydownHandler]);\n      this[$progressTracker].removeEventListener('progress', this[$progressHandler]);\n      loadingStatusAnnouncer.unregisterInstance(this);\n    }\n\n    async updated(changedProperties) {\n      super.updated(changedProperties);\n\n      if (changedProperties.has('poster') && this.poster != null) {\n        this[$defaultPosterElement].style.backgroundImage = \"url(\".concat(this.poster, \")\");\n      }\n\n      if (changedProperties.has('src')) {\n        this[$posterDismissalSource] = null;\n        this[$preloadAttempted] = false;\n        this[$lastReportedProgress] = 0;\n        this[$sourceUpdated] = false;\n      }\n\n      if (changedProperties.has('alt')) {\n        this[$defaultPosterElement].setAttribute('aria-label', \"\".concat(this[$ariaLabel], \". \").concat(this[$ariaLabelCallToAction]));\n      }\n\n      this[$updateLoadingAndVisibility]();\n    }\n\n    [(_a = $modelIsVisible, _b = $preloadAttempted, _c = $sourceUpdated, _d = $lastReportedProgress, _e = $posterDismissalSource, _f = $posterContainerElement, _g = $defaultPosterElement, _h = $defaultProgressBarElement, _j = $defaultProgressMaskElement, _k = $ariaLabelCallToAction, _l = $clickHandler, _m = $keydownHandler, _o = $progressHandler, _p = $announceModelVisibility, _q = $updateProgressBar, $onClick)]() {\n      this[$posterDismissalSource] = PosterDismissalSource.INTERACTION;\n      this.requestUpdate();\n    }\n\n    [$onKeydown](event) {\n      switch (event.keyCode) {\n        // NOTE(cdata): Links and buttons can typically be activated with\n        // both spacebar and enter to produce a synthetic click action\n        case SPACE_KEY:\n        case ENTER_KEY:\n          this[$posterDismissalSource] = PosterDismissalSource.INTERACTION;\n          break;\n\n        default:\n          break;\n      }\n\n      this.requestUpdate();\n    }\n\n    [$onProgress](event) {\n      const progress = event.detail.totalProgress;\n      this.requestUpdate();\n\n      if (progress === 1.0) {\n        this[$updateProgressBar].flush();\n      }\n\n      this[$updateProgressBar](progress);\n      this.dispatchEvent(new CustomEvent('progress', {\n        detail: {\n          totalProgress: progress\n        }\n      }));\n      this[$lastReportedProgress] = Math.max(progress, this[$lastReportedProgress]);\n    }\n\n    get [$modelIsReadyForReveal]() {\n      const src = this.src;\n      return !!src && CachingGLTFLoader.hasFinishedLoading(src) && this[$lastReportedProgress] === 1.0 && this[$shouldRevealModel];\n    }\n\n    get [$shouldRevealModel]() {\n      return this.reveal === RevealStrategy.AUTO || !!this[$posterDismissalSource];\n    }\n\n    get [$shouldAttemptPreload]() {\n      const src = this.src;\n      return !!src && !CachingGLTFLoader.hasFinishedLoading(src) && (this.preload || this[$shouldRevealModel]);\n    }\n\n    async [$updateLoadingAndVisibility]() {\n      if (this[$shouldAttemptPreload] && !this[$preloadAttempted]) {\n        this[$preloadAttempted] = true;\n        const updatePreloadProgress = this[$progressTracker].beginActivity();\n\n        try {\n          const src = this.src;\n          const detail = {\n            url: src\n          };\n          await loader.preload(src, updatePreloadProgress);\n          this.dispatchEvent(new CustomEvent('preload', {\n            detail\n          }));\n        } catch (error) {\n          this.dispatchEvent(new CustomEvent('error', {\n            detail: {\n              type: 'preload',\n              sourceError: error\n            }\n          }));\n        } finally {\n          updatePreloadProgress(1.0);\n          this.requestUpdate();\n        }\n      }\n\n      if (this[$modelIsReadyForReveal]) {\n        if (!this[$sourceUpdated]) {\n          this[$updateSource]();\n          this[$hidePoster]();\n        }\n      } else {\n        this[$showPoster]();\n      }\n    }\n\n    [$showPoster]() {\n      const posterContainerElement = this[$posterContainerElement];\n      const defaultPosterElement = this[$defaultPosterElement];\n      const posterContainerOpacity = parseFloat(self.getComputedStyle(posterContainerElement).opacity);\n      defaultPosterElement.tabIndex = 1;\n      defaultPosterElement.removeAttribute('aria-hidden');\n      posterContainerElement.classList.add('show');\n\n      if (posterContainerOpacity < 1.0) {\n        posterContainerElement.addEventListener('transitionend', () => {\n          this[$modelIsVisible] = false;\n          this[$announceModelVisibility](false);\n        }, {\n          once: true\n        });\n      }\n    }\n\n    [$hidePoster]() {\n      const posterContainerElement = this[$posterContainerElement];\n      const defaultPosterElement = this[$defaultPosterElement];\n\n      if (posterContainerElement.classList.contains('show')) {\n        posterContainerElement.classList.remove('show'); // We might need to forward focus to our internal canvas, but that\n        // cannot happen until the poster has completely transitioned away\n\n        posterContainerElement.addEventListener('transitionend', () => {\n          this[$announceModelVisibility](true);\n          requestAnimationFrame(() => {\n            this[$modelIsVisible] = true;\n            const root = this.getRootNode(); // If the <model-viewer> is still focused, forward the focus to\n            // the canvas that has just been revealed\n\n            if (root && root.activeElement === this) {\n              this[$canvas].focus();\n            } // Ensure that the poster is no longer focusable or visible to\n            // screen readers\n\n\n            defaultPosterElement.setAttribute('aria-hidden', 'true');\n            defaultPosterElement.removeAttribute('tabindex');\n          });\n        }, {\n          once: true\n        });\n      }\n    }\n\n    async [$updateSource]() {\n      if (this[$modelIsReadyForReveal]) {\n        this[$sourceUpdated] = true;\n        await super[$updateSource]();\n      }\n    }\n\n  }\n\n  __decorate([property({\n    converter: {\n      fromAttribute: deserializeUrl\n    }\n  })], LoadingModelViewerElement.prototype, \"poster\", void 0);\n\n  __decorate([property({\n    type: String\n  })], LoadingModelViewerElement.prototype, \"reveal\", void 0);\n\n  __decorate([property({\n    type: Boolean\n  })], LoadingModelViewerElement.prototype, \"preload\", void 0);\n\n  return LoadingModelViewerElement;\n};","map":null,"metadata":{},"sourceType":"module"}