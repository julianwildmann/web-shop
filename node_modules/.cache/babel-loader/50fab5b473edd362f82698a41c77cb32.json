{"ast":null,"code":"/*\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { property } from 'lit-element';\nimport { $needsRender, $onModelLoad, $scene, $tick, $updateSource } from '../model-viewer-base.js';\nconst MILLISECONDS_PER_SECOND = 1000.0;\nconst $changeAnimation = Symbol('changeAnimation');\nconst $paused = Symbol('paused');\nexport const AnimationMixin = ModelViewerElement => {\n  var _a;\n\n  class AnimationModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.autoplay = false;\n      this.animationName = undefined;\n      this.animationCrossfadeDuration = 300;\n      this[_a] = true;\n    }\n    /**\n     * Returns an array\n     */\n\n\n    get availableAnimations() {\n      if (this.loaded) {\n        return this[$scene].model.animationNames;\n      }\n\n      return [];\n    }\n\n    get paused() {\n      return this[$paused];\n    }\n\n    get currentTime() {\n      return this[$scene].model.animationTime;\n    }\n\n    set currentTime(value) {\n      this[$scene].model.animationTime = value;\n    }\n\n    pause() {\n      if (this[$paused]) {\n        return;\n      }\n\n      this[$paused] = true;\n      this.dispatchEvent(new CustomEvent('pause'));\n    }\n\n    play() {\n      if (this[$paused] && this.availableAnimations.length > 0) {\n        this[$paused] = false;\n\n        if (!this[$scene].model.hasActiveAnimation) {\n          this[$changeAnimation]();\n        }\n\n        this.dispatchEvent(new CustomEvent('play'));\n      }\n    }\n\n    [(_a = $paused, $onModelLoad)]() {\n      this[$paused] = true;\n\n      if (this.autoplay) {\n        this[$changeAnimation]();\n        this.play();\n      }\n    }\n\n    [$tick](_time, delta) {\n      super[$tick](_time, delta);\n\n      if (this[$paused]) {\n        return;\n      }\n\n      const model = this[$scene].model;\n      model.updateAnimation(delta / MILLISECONDS_PER_SECOND);\n      this[$needsRender]();\n    }\n\n    updated(changedProperties) {\n      super.updated(changedProperties);\n\n      if (changedProperties.has('autoplay') && this.autoplay) {\n        this.play();\n      }\n\n      if (changedProperties.has('animationName')) {\n        this[$changeAnimation]();\n      }\n    }\n\n    async [$updateSource]() {\n      super[$updateSource](); // If we are loading a new model, we need to stop the animation of\n      // the current one (if any is playing). Otherwise, we might lose\n      // the reference to the scene root and running actions start to\n      // throw exceptions and/or behave in unexpected ways:\n\n      this[$scene].model.stopAnimation();\n    }\n\n    [$changeAnimation]() {\n      const model = this[$scene].model;\n      model.playAnimation(this.animationName, this.animationCrossfadeDuration / MILLISECONDS_PER_SECOND); // If we are currently paused, we need to force a render so that\n      // the model updates to the first frame of the new animation\n\n      if (this[$paused]) {\n        model.updateAnimation(0);\n        this[$needsRender]();\n      }\n    }\n\n  }\n\n  __decorate([property({\n    type: Boolean\n  })], AnimationModelViewerElement.prototype, \"autoplay\", void 0);\n\n  __decorate([property({\n    type: String,\n    attribute: 'animation-name'\n  })], AnimationModelViewerElement.prototype, \"animationName\", void 0);\n\n  __decorate([property({\n    type: Number,\n    attribute: 'animation-crossfade-duration'\n  })], AnimationModelViewerElement.prototype, \"animationCrossfadeDuration\", void 0);\n\n  return AnimationModelViewerElement;\n};","map":null,"metadata":{},"sourceType":"module"}