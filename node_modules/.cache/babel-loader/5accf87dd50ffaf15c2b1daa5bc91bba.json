{"ast":null,"code":"/*\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { HAS_FULLSCREEN_API, HAS_WEBXR_DEVICE_API, HAS_WEBXR_HIT_TEST_API, IS_WEBXR_AR_CANDIDATE } from './constants.js';\nimport Timer from './utilities/timer';\nexport { Timer };\nexport const deserializeUrl = url => url != null && url !== 'null' ? toFullUrl(url) : null;\nexport const assertIsArCandidate = () => {\n  if (IS_WEBXR_AR_CANDIDATE) {\n    return;\n  }\n\n  const missingApis = [];\n\n  if (!HAS_FULLSCREEN_API) {\n    missingApis.push('Fullscreen API');\n  }\n\n  if (!HAS_WEBXR_DEVICE_API) {\n    missingApis.push('WebXR Device API');\n  }\n\n  if (!HAS_WEBXR_HIT_TEST_API) {\n    missingApis.push('WebXR Hit Test API');\n  }\n\n  throw new Error(\"The following APIs are required for AR, but are missing in this browser: \".concat(missingApis.join(', ')));\n};\n/**\n * Converts a partial URL string to a fully qualified URL string.\n *\n * @param {String} url\n * @return {String}\n */\n\nexport const toFullUrl = partialUrl => {\n  const url = new URL(partialUrl, window.location.toString());\n  return url.toString();\n};\n/**\n * Returns a throttled version of a given function that is only invoked at most\n * once within a given threshold of time in milliseconds.\n *\n * The throttled version of the function has a \"flush\" property that resets the\n * threshold for cases when immediate invokation is desired.\n */\n\nexport const throttle = (fn, ms) => {\n  let timer = null;\n\n  const throttled = (...args) => {\n    if (timer != null) {\n      return;\n    }\n\n    fn(...args);\n    timer = self.setTimeout(() => timer = null, ms);\n  };\n\n  throttled.flush = () => {\n    if (timer != null) {\n      self.clearTimeout(timer);\n      timer = null;\n    }\n  };\n\n  return throttled;\n};\nexport const debounce = (fn, ms) => {\n  let timer = null;\n  return (...args) => {\n    if (timer != null) {\n      self.clearTimeout(timer);\n    }\n\n    timer = self.setTimeout(() => {\n      timer = null;\n      fn(...args);\n    }, ms);\n  };\n};\n/**\n * @param {Number} edge\n * @param {Number} value\n * @return {Number} 0 if value is less than edge, otherwise 1\n */\n\nexport const step = (edge, value) => {\n  return value < edge ? 0 : 1;\n};\n/**\n * @param {Number} value\n * @param {Number} lowerLimit\n * @param {Number} upperLimit\n * @return {Number} value clamped within lowerLimit..upperLimit\n */\n\nexport const clamp = (value, lowerLimit, upperLimit) => Math.max(lowerLimit === -Infinity ? value : lowerLimit, Math.min(upperLimit === Infinity ? value : upperLimit, value)); // The DPR we use for a \"capped\" scenario (see resolveDpr below):\n\nexport const CAPPED_DEVICE_PIXEL_RATIO = 1;\n/**\n * This helper analyzes the layout of the current page to decide if we should\n * use the natural device pixel ratio, or a capped value.\n *\n * We cap DPR if there is no meta viewport (suggesting that user is not\n * consciously specifying how to scale the viewport relative to the device\n * screen size).\n *\n * The rationale is that this condition typically leads to a pathological\n * outcome on mobile devices. When the window dimensions are scaled up on a\n * device with a high DPR, we create a canvas that is much larger than\n * appropriate to accomodate for the pixel density if we naively use the\n * reported DPR.\n *\n * This value needs to be measured in real time, as device pixel ratio can\n * change over time (e.g., when a user zooms the page). Also, in some cases\n * (such as Firefox on Android), the window's innerWidth is initially reported\n * as the same as the screen's availWidth but changes later.\n *\n * A user who specifies a meta viewport, thereby consciously creating scaling\n * conditions where <model-viewer> is slow, will be encouraged to live their\n * best life.\n */\n\nexport const resolveDpr = (() => {\n  // If true, implies that the user is conscious of the viewport scaling\n  // relative to the device screen size.\n  const HAS_META_VIEWPORT_TAG = (() => {\n    const metas = document.head != null ? Array.from(document.head.querySelectorAll('meta')) : [];\n\n    for (const meta of metas) {\n      if (meta.name === 'viewport') {\n        return true;\n      }\n    }\n\n    return false;\n  })();\n\n  if (!HAS_META_VIEWPORT_TAG) {\n    console.warn('No <meta name=\"viewport\"> detected; <model-viewer> will cap pixel density at 1.');\n  }\n\n  return () => HAS_META_VIEWPORT_TAG ? window.devicePixelRatio : CAPPED_DEVICE_PIXEL_RATIO;\n})();\n/**\n * Returns the first key in a Map in iteration order.\n *\n * NOTE(cdata): This is necessary because IE11 does not implement iterator\n * methods of Map, and polymer-build does not polyfill these methods for\n * compatibility and performance reasons. This helper proposes that it is\n * a reasonable compromise to sacrifice a very small amount of runtime\n * performance in IE11 for the sake of code clarity.\n */\n\nexport const getFirstMapKey = map => {\n  if (map.keys != null) {\n    return map.keys().next().value || null;\n  }\n\n  let firstKey = null;\n\n  try {\n    map.forEach((_value, key, _map) => {\n      firstKey = key; // Stop iterating the Map with forEach:\n\n      throw new Error();\n    });\n  } catch (_error) {}\n\n  return firstKey;\n};","map":null,"metadata":{},"sourceType":"module"}