{"ast":null,"code":"/*\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar _a, _b, _c, _d, _e, _f;\n\nimport { property } from 'lit-element';\nimport { UpdatingElement } from 'lit-element/lib/updating-element';\nimport { HAS_INTERSECTION_OBSERVER, HAS_RESIZE_OBSERVER } from './constants.js';\nimport { makeTemplate } from './template.js';\nimport ModelScene from './three-components/ModelScene.js';\nimport Renderer from './three-components/Renderer.js';\nimport { debounce, deserializeUrl, resolveDpr } from './utilities.js';\nimport { ProgressTracker } from './utilities/progress-tracker.js';\nlet renderer = new Renderer();\nconst FALLBACK_SIZE_UPDATE_THRESHOLD_MS = 50;\nconst UNSIZED_MEDIA_WIDTH = 300;\nconst UNSIZED_MEDIA_HEIGHT = 150;\nconst $updateSize = Symbol('updateSize');\nconst $loaded = Symbol('loaded');\nconst $template = Symbol('template');\nconst $fallbackResizeHandler = Symbol('fallbackResizeHandler');\nconst $defaultAriaLabel = Symbol('defaultAriaLabel');\nconst $resizeObserver = Symbol('resizeObserver');\nconst $intersectionObserver = Symbol('intersectionObserver');\nconst $lastDpr = Symbol('lastDpr');\nexport const $ariaLabel = Symbol('ariaLabel');\nexport const $updateSource = Symbol('updateSource');\nexport const $markLoaded = Symbol('markLoaded');\nexport const $container = Symbol('container');\nexport const $canvas = Symbol('canvas');\nexport const $scene = Symbol('scene');\nexport const $needsRender = Symbol('needsRender');\nexport const $tick = Symbol('tick');\nexport const $onModelLoad = Symbol('onModelLoad');\nexport const $onResize = Symbol('onResize');\nexport const $onUserModelOrbit = Symbol('onUserModelOrbit');\nexport const $renderer = Symbol('renderer');\nexport const $resetRenderer = Symbol('resetRenderer');\nexport const $progressTracker = Symbol('progressTracker');\n/**\n * Definition for a basic <model-viewer> element.\n */\n\nexport default class ModelViewerElementBase extends UpdatingElement {\n  /**\n   * Creates a new ModelViewerElement.\n   */\n  constructor() {\n    super();\n    this.alt = null;\n    this.src = null;\n    this[_a] = false;\n    this[_b] = resolveDpr();\n    this[_c] = debounce(() => {\n      const boundingRect = this.getBoundingClientRect();\n      this[$updateSize](boundingRect);\n    }, FALLBACK_SIZE_UPDATE_THRESHOLD_MS);\n    this[_d] = null;\n    this[_e] = null;\n    this[_f] = new ProgressTracker(); // NOTE(cdata): It is *very important* to access this template first so that\n    // the ShadyCSS template preparation steps happen before element styling in\n    // IE11:\n\n    const template = this.constructor.template;\n\n    if (window.ShadyCSS) {\n      window.ShadyCSS.styleElement(this, {});\n    } // NOTE(cdata): The canonical ShadyCSS examples suggest that the Shadow Root\n    // should be created after the invocation of ShadyCSS.styleElement\n\n\n    this.attachShadow({\n      mode: 'open',\n      delegatesFocus: true\n    });\n    const shadowRoot = this.shadowRoot;\n    shadowRoot.appendChild(template.content.cloneNode(true));\n    this[$container] = shadowRoot.querySelector('.container');\n    this[$canvas] = shadowRoot.querySelector('canvas');\n    this[$defaultAriaLabel] = this[$canvas].getAttribute('aria-label'); // Because of potential race conditions related to invoking the constructor\n    // we only use the bounding rect to set the initial size if the element is\n    // already connected to the document:\n\n    let width, height;\n\n    if (this.isConnected) {\n      const rect = this.getBoundingClientRect();\n      width = rect.width;\n      height = rect.height;\n    } else {\n      width = UNSIZED_MEDIA_WIDTH;\n      height = UNSIZED_MEDIA_HEIGHT;\n    } // Create the underlying ModelScene.\n\n\n    this[$scene] = new ModelScene({\n      canvas: this[$canvas],\n      element: this,\n      width,\n      height,\n      renderer\n    });\n    this[$scene].addEventListener('model-load', event => {\n      this[$markLoaded]();\n      this[$onModelLoad](event);\n      this.dispatchEvent(new CustomEvent('load', {\n        detail: {\n          url: event.url\n        }\n      }));\n    }); // Update initial size on microtask timing so that subclasses have a\n    // chance to initialize\n\n    Promise.resolve().then(() => {\n      this[$updateSize](this.getBoundingClientRect(), true);\n    });\n\n    if (HAS_RESIZE_OBSERVER) {\n      // Set up a resize observer so we can scale our canvas\n      // if our <model-viewer> changes\n      this[$resizeObserver] = new ResizeObserver(entries => {\n        // Don't resize anything if in AR mode; otherwise the canvas\n        // scaling to fullscreen on entering AR will clobber the flat/2d\n        // dimensions of the element.\n        if (renderer.isPresenting) {\n          return;\n        }\n\n        for (let entry of entries) {\n          if (entry.target === this) {\n            this[$updateSize](entry.contentRect);\n          }\n        }\n      });\n    }\n\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver] = new IntersectionObserver(entries => {\n        for (let entry of entries) {\n          if (entry.target === this) {\n            this[$scene].isVisible = entry.isIntersecting;\n          }\n        }\n      }, {\n        root: null,\n        rootMargin: '10px',\n        threshold: 0\n      });\n    } else {\n      // If there is no intersection obsever, then all models should be visible\n      // at all times:\n      this[$scene].isVisible = true;\n    }\n  }\n\n  static get is() {\n    return 'model-viewer';\n  }\n\n  static get template() {\n    if (!this.hasOwnProperty($template)) {\n      this[$template] = makeTemplate(this.is);\n    }\n\n    return this[$template];\n  }\n\n  static [$resetRenderer]() {\n    renderer.dispose();\n    renderer = new Renderer();\n  }\n\n  get loaded() {\n    return this[$loaded];\n  }\n\n  get [(_a = $loaded, _b = $lastDpr, _c = $fallbackResizeHandler, _d = $resizeObserver, _e = $intersectionObserver, _f = $progressTracker, $renderer)]() {\n    return renderer;\n  }\n\n  get modelIsVisible() {\n    return true;\n  }\n\n  connectedCallback() {\n    super.connectedCallback && super.connectedCallback();\n\n    if (HAS_RESIZE_OBSERVER) {\n      this[$resizeObserver].observe(this);\n    } else {\n      self.addEventListener('resize', this[$fallbackResizeHandler]);\n    }\n\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver].observe(this);\n    }\n\n    this[$renderer].registerScene(this[$scene]);\n    this[$scene].isDirty = true;\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback && super.disconnectedCallback();\n\n    if (HAS_RESIZE_OBSERVER) {\n      this[$resizeObserver].unobserve(this);\n    } else {\n      self.removeEventListener('resize', this[$fallbackResizeHandler]);\n    }\n\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver].unobserve(this);\n    }\n\n    this[$renderer].unregisterScene(this[$scene]);\n  }\n\n  updated(changedProperties) {\n    super.updated(changedProperties); // NOTE(cdata): If a property changes from values A -> B -> A in the space\n    // of a microtask, LitElement/UpdatingElement will notify of a change even\n    // though the value has effectively not changed, so we need to check to make\n    // sure that the value has actually changed before changing the loaded flag.\n\n    if (changedProperties.has('src') && this.src !== this[$scene].model.url) {\n      this[$loaded] = false;\n\n      (async () => {\n        const updateSourceProgress = this[$progressTracker].beginActivity();\n        await this[$updateSource](progress => updateSourceProgress(progress * 0.9));\n        updateSourceProgress(1.0);\n      })();\n    }\n\n    if (changedProperties.has('alt')) {\n      const ariaLabel = this.alt == null ? this[$defaultAriaLabel] : this.alt;\n      this[$canvas].setAttribute('aria-label', ariaLabel);\n    }\n  }\n\n  toDataURL(type, encoderOptions) {\n    return this[$canvas].toDataURL(type, encoderOptions);\n  }\n\n  get [$ariaLabel]() {\n    return this.alt == null || this.alt === 'null' ? this[$defaultAriaLabel] : this.alt;\n  }\n  /**\n   * Called on initialization and when the resize observer fires.\n   */\n\n\n  [$updateSize]({\n    width,\n    height\n  }, forceApply = false) {\n    const _this$$scene$getSize = this[$scene].getSize(),\n          prevWidth = _this$$scene$getSize.width,\n          prevHeight = _this$$scene$getSize.height; // Round off the pixel size\n\n\n    const intWidth = parseInt(width, 10);\n    const intHeight = parseInt(height, 10);\n    this[$container].style.width = \"\".concat(width, \"px\");\n    this[$container].style.height = \"\".concat(height, \"px\");\n\n    if (forceApply || prevWidth !== intWidth || prevHeight !== intHeight) {\n      this[$onResize]({\n        width: intWidth,\n        height: intHeight\n      });\n    }\n  }\n\n  [$tick](_time, _delta) {\n    const dpr = resolveDpr(); // There is no standard way to detect when DPR changes on account of zoom.\n    // Here we keep a local copy of DPR updated, and when it changes we invoke\n    // the fallback resize handler. It might be better to invoke the resize\n    // handler directly in this case, but the fallback is debounced which will\n    // save us from doing too much work when DPR and window size changes at the\n    // same time.\n\n    if (dpr !== this[$lastDpr]) {\n      this[$lastDpr] = dpr;\n      this[$fallbackResizeHandler]();\n    }\n  }\n\n  [$markLoaded]() {\n    if (this[$loaded]) {\n      return;\n    }\n\n    this[$loaded] = true; // Asynchronously invoke `update`:\n\n    this.requestUpdate();\n  }\n\n  [$needsRender]() {\n    this[$scene].isDirty = true;\n  }\n\n  [$onModelLoad](_event) {\n    this[$needsRender]();\n  }\n\n  [$onResize](e) {\n    this[$scene].setSize(e.width, e.height);\n    this[$needsRender]();\n  }\n\n  [$onUserModelOrbit]() {}\n  /**\n   * Parses the element for an appropriate source URL and\n   * sets the views to use the new model based off of the `preload`\n   * attribute.\n   */\n\n\n  async [$updateSource](progressCallback = () => {}) {\n    const source = this.src;\n\n    try {\n      this[$canvas].classList.add('show');\n      await this[$scene].setModelSource(source, progressCallback);\n    } catch (error) {\n      this[$canvas].classList.remove('show');\n      this.dispatchEvent(new CustomEvent('error', {\n        detail: error\n      }));\n    }\n  }\n\n}\n\n__decorate([property({\n  type: String\n})], ModelViewerElementBase.prototype, \"alt\", void 0);\n\n__decorate([property({\n  converter: {\n    fromAttribute: deserializeUrl\n  }\n})], ModelViewerElementBase.prototype, \"src\", void 0);","map":null,"metadata":{},"sourceType":"module"}