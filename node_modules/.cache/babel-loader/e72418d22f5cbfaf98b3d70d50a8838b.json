{"ast":null,"code":"var _a, _b, _c, _d, _e, _f, _g, _h;\n\nimport { EventDispatcher, Matrix4, Object3D, PerspectiveCamera, Raycaster, Scene, Vector3, WebGLRenderer } from 'three';\nimport { assertIsArCandidate } from '../utilities.js';\nimport Reticle from './Reticle.js';\nimport { assertContext } from './WebGLUtils.js';\nconst $presentedScene = Symbol('presentedScene');\nconst $device = Symbol('device');\nconst $devicePromise = Symbol('devicePromise');\nconst $rafId = Symbol('rafId');\nconst $currentSession = Symbol('currentSession');\nconst $tick = Symbol('tick');\nconst $refSpace = Symbol('refSpace');\nconst $resolveCleanup = Symbol('resolveCleanup');\nconst $outputCanvas = Symbol('outputCanvas');\nconst $outputContext = Symbol('outputContext');\nconst $onWebXRFrame = Symbol('onWebXRFrame');\nconst $postSessionCleanup = Symbol('postSessionCleanup');\nconst matrix4 = new Matrix4();\nconst vector3 = new Vector3();\nconst originArray = new Float32Array(3);\nconst directionArray = new Float32Array(3);\nexport class ARRenderer extends EventDispatcher {\n  constructor(inputCanvas, inputContext) {\n    super();\n    this.camera = new PerspectiveCamera();\n    this.scene = new Scene();\n    this.dolly = new Object3D();\n    this.reticle = new Reticle(this.camera);\n    this.raycaster = null;\n    this[_a] = null;\n    this[_b] = null;\n    this[_c] = null;\n    this[_d] = null;\n    this[_e] = null;\n    this[_f] = null;\n    this[_g] = null;\n    this[_h] = null;\n    this.renderer = null;\n    this.inputCanvas = inputCanvas;\n    this.inputContext = inputContext;\n    this.camera.matrixAutoUpdate = false;\n    this.scene.add(this.reticle);\n    this.scene.add(this.dolly); // NOTE: XRDevice is being removed\n    // @see https://github.com/immersive-web/webxr/pull/405\n\n    this[$devicePromise] = this.resolveDevice().then(device => {\n      return this[$device] = device;\n    }).catch(error => {\n      console.warn(error);\n      console.warn('Browser AR will be disabled');\n    });\n  }\n  /**\n   * Given an inline Renderer, construct an ARRenderer and return it\n   */\n\n\n  static fromInlineRenderer(renderer) {\n    return new ARRenderer(renderer.canvas, renderer.context);\n  }\n\n  initializeRenderer() {\n    if (this.renderer != null) {\n      return;\n    }\n\n    this.renderer = new WebGLRenderer({\n      canvas: this.inputCanvas,\n      context: this.inputContext\n    });\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.renderer.setPixelRatio(1);\n    this.renderer.autoClear = false;\n    this.renderer.gammaOutput = true;\n    this.renderer.gammaFactor = 2.2;\n  }\n\n  async resolveDevice() {\n    assertIsArCandidate();\n    return await navigator.xr.requestDevice();\n  }\n\n  async resolveARSession() {\n    assertIsArCandidate();\n    const device = this[$device];\n    const session = await device.requestSession({\n      environmentIntegration: true,\n      outputContext: this.outputContext\n    });\n    const gl = assertContext(this.renderer.getContext()); // `makeXRCompatible` replaced `setCompatibleXRDevice` in Chrome M73\n    // @TODO #293, handle WebXR API changes\n\n    if ('setCompatibleXRDevice' in gl) {\n      await gl.setCompatibleXRDevice(device);\n    } else {\n      await gl.makeXRCompatible();\n    }\n\n    session.baseLayer = new XRWebGLLayer(session, gl, {\n      alpha: true\n    });\n    this.renderer.setFramebuffer(session.baseLayer.framebuffer);\n    return session;\n  }\n  /**\n   * The currently presented scene, if any\n   */\n\n\n  get presentedScene() {\n    return this[$presentedScene];\n  }\n  /**\n   * Resolves to true if the renderer has detected all the necessary qualities\n   * to support presentation in AR.\n   */\n\n\n  async supportsPresentation() {\n    try {\n      assertIsArCandidate();\n      const device = await this[$devicePromise];\n      await device.supportsSession({\n        environmentIntegration: true,\n        outputContext: this.outputContext\n      });\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n  /**\n   * Present a scene in AR\n   */\n\n\n  async present(scene) {\n    if (this.isPresenting) {\n      console.warn('Cannot present while a model is already presenting');\n      return this.outputCanvas;\n    }\n\n    scene.model.scale.set(1, 1, 1);\n    this[$presentedScene] = scene;\n    this.initializeRenderer();\n    this[$currentSession] = await this.resolveARSession();\n    this[$currentSession].addEventListener('end', () => {\n      this[$postSessionCleanup]();\n    }, {\n      once: true\n    }); // `requestReferenceSpace` replaced `requestFrameOfReference` in Chrome M73\n    // @TODO #293, handle WebXR API changes\n\n    this[$refSpace] = await ('requestFrameOfReference' in this[$currentSession] ? this[$currentSession].requestFrameOfReference('eye-level') : this[$currentSession].requestReferenceSpace({\n      type: 'stationary',\n      subtype: 'eye-level'\n    }));\n    this[$tick]();\n    return this.outputCanvas;\n  }\n  /**\n   * If currently presenting a scene in AR, stops presentation and exits AR.\n   */\n\n\n  async stopPresenting() {\n    if (!this.isPresenting) {\n      return;\n    }\n\n    const cleanupPromise = new Promise(resolve => {\n      this[$resolveCleanup] = resolve;\n    });\n\n    try {\n      const session = this[$currentSession];\n      this[$currentSession] = null;\n      session.cancelAnimationFrame(this[$rafId]);\n      await session.end();\n      await cleanupPromise;\n    } catch (error) {\n      console.warn('Error while trying to end AR session');\n      console.warn(error);\n      this[$postSessionCleanup]();\n    }\n  }\n\n  [(_a = $outputCanvas, _b = $outputContext, _c = $rafId, _d = $currentSession, _e = $refSpace, _f = $presentedScene, _g = $resolveCleanup, _h = $device, $postSessionCleanup)]() {\n    if (this[$presentedScene] != null) {\n      this.dolly.remove(this[$presentedScene]);\n      this[$presentedScene].updateFraming();\n      this[$presentedScene].alignModel();\n    }\n\n    this[$refSpace] = null;\n    this[$presentedScene] = null;\n\n    if (this.outputCanvas.parentNode != null) {\n      this.outputCanvas.parentNode.removeChild(this.outputCanvas);\n    }\n\n    if (this[$resolveCleanup] != null) {\n      this[$resolveCleanup]();\n    }\n  }\n  /**\n   * True if a scene is currently in the process of being presented in AR\n   */\n\n\n  get isPresenting() {\n    return this[$presentedScene] != null;\n  }\n\n  get outputCanvas() {\n    if (this[$outputCanvas] == null) {\n      this[$outputCanvas] = document.createElement('canvas');\n      this[$outputCanvas].setAttribute('style', \"\\ndisplay: block;\\nposition: absolute;\\ntop: 0px;\\nleft: 0px;\\nwidth: 100%;\\nheight: 100%;\");\n    }\n\n    return this[$outputCanvas];\n  }\n\n  get outputContext() {\n    if (this[$outputContext] == null) {\n      this[$outputContext] = this.outputCanvas.getContext('xrpresent');\n    }\n\n    return this[$outputContext];\n  }\n\n  async placeModel() {\n    if (this[$currentSession] == null) {\n      return;\n    }\n\n    if (this.raycaster == null) {\n      this.raycaster = new Raycaster();\n    } // NOTE: Currently rays will be cast from the middle of the screen.\n    // Eventually we might use input coordinates for this.\n\n\n    this.raycaster.setFromCamera({\n      x: 0,\n      y: 0\n    }, this.camera);\n    const ray = this.raycaster.ray;\n    originArray.set(ray.origin.toArray());\n    directionArray.set(ray.direction.toArray());\n    let hits;\n\n    try {\n      hits = await this[$currentSession].requestHitTest(originArray, directionArray, this[$refSpace]);\n    } catch (e) {// Spec says this should no longer throw on invalid requests:\n      // https://github.com/immersive-web/hit-test/issues/24\n      // But in practice, it will still happen, so just ignore:\n      // https://github.com/immersive-web/hit-test/issues/37\n    }\n\n    if (hits && hits.length) {\n      const presentedScene = this[$presentedScene];\n      const hit = hits[0];\n      const hitMatrix = matrix4.fromArray(hit.hitMatrix);\n      this.dolly.position.setFromMatrixPosition(hitMatrix); // Orient the dolly/model to face the camera\n\n      const camPosition = vector3.setFromMatrixPosition(this.camera.matrix);\n      this.dolly.lookAt(camPosition.x, this.dolly.position.y, camPosition.z);\n      this.dolly.rotateY(-presentedScene.pivot.rotation.y);\n      this.dolly.add(presentedScene);\n      this.dispatchEvent({\n        type: 'modelmove'\n      });\n    }\n  }\n  /**\n   * It appears that XRSession's `inputsourceschange` event is not implemented\n   * in Chrome Canary as of m72 for 'screen' inputs, which would be preferable\n   * since we only need an \"select\" event, rather than track a pose on every\n   * frame (like a 6DOF controller). Due to this bug, on every frame, check to\n   * see if an input exists.\n   * @see https://bugs.chromium.org/p/chromium/issues/detail?id=913703\n   * @see https://immersive-web.github.io/webxr/#xrinputsource-interface\n   */\n\n\n  processXRInput(frame) {\n    const session = frame.session; // Get current input sources. For now, only 'screen' input is supported,\n    // which is only added to the session's active input sources immediately\n    // before `selectstart` and removed immediately after `selectend` event.\n    // If we have a 'screen' source here, it means the output canvas was tapped.\n\n    const sources = session.getInputSources().filter(input => input.targetRayMode === 'screen');\n\n    if (sources.length === 0) {\n      return;\n    }\n\n    const pose = frame.getInputPose(sources[0], this[$refSpace]);\n\n    if (pose) {\n      this.placeModel();\n    }\n  }\n\n  [$tick]() {\n    this[$rafId] = this[$currentSession].requestAnimationFrame((time, frame) => this[$onWebXRFrame](time, frame));\n  }\n\n  [$onWebXRFrame](_time, frame) {\n    const session = frame.session; // `getViewerPose` replaced `getDevicePose` in Chrome M73\n    // @TODO #293, handle WebXR API changes\n\n    const pose = 'getDevicePose' in frame ? frame.getDevicePose(this[$refSpace]) : frame.getViewerPose(this[$refSpace]); // TODO: Notify external observers of tick\n    // TODO: Note that reticle may be \"stabilized\"\n\n    this[$tick]();\n\n    if (pose == null) {\n      return;\n    }\n\n    for (const view of frame.views) {\n      const viewport = session.baseLayer.getViewport(view);\n      this.renderer.setViewport(0, 0, viewport.width, viewport.height);\n      this.renderer.setSize(viewport.width, viewport.height, false);\n      this.camera.projectionMatrix.fromArray(view.projectionMatrix);\n      const viewMatrix = matrix4.fromArray(pose.getViewMatrix(view));\n      this.camera.matrix.getInverse(viewMatrix);\n      this.camera.updateMatrixWorld(true); // NOTE: Updating input or the reticle is dependent on the camera's\n      // pose, hence updating these elements after camera update but\n      // before render.\n\n      this.reticle.update(this[$currentSession], this[$refSpace]);\n      this.processXRInput(frame); // NOTE: Clearing depth caused issues on Samsung devices\n      // @see https://github.com/googlecodelabs/ar-with-webxr/issues/8\n      // this.renderer.clearDepth();\n\n      this.renderer.render(this.scene, this.camera);\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}