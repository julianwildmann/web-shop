{"ast":null,"code":"/*\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Mesh, MeshBasicMaterial, OrthographicCamera, PlaneGeometry, RGBAFormat, Vector3, WebGLRenderTarget } from 'three';\nconst $camera = Symbol('camera');\nconst $renderTarget = Symbol('renderTarget');\nconst scale = new Vector3();\nconst BASE_SHADOW_OPACITY = 0.1;\nconst DEFAULT_CONFIG = {\n  near: 0.01,\n  far: 100,\n  textureWidth: 512,\n  textureHeight: 512\n};\nconst shadowGeneratorMaterial = new MeshBasicMaterial({\n  color: 0x000000\n});\nconst shadowTextureMaterial = new MeshBasicMaterial({\n  transparent: true,\n  opacity: BASE_SHADOW_OPACITY\n});\n/**\n * Creates a mesh that can receive and render pseudo-shadows\n * only updated when calling its render method. This is different\n * from non-auto-updating shadows because the resulting material\n * applied to the mesh is disconnected from the renderer's shadow map\n * and can be freely rotated and positioned like a regular texture.\n */\n\nexport default class StaticShadow extends Mesh {\n  /**\n   * Create a shadow mesh.\n   */\n  constructor() {\n    const geometry = new PlaneGeometry(1, 1);\n    geometry.rotateX(-Math.PI / 2);\n    super(geometry, shadowTextureMaterial.clone());\n    this.name = 'StaticShadow';\n    this[$renderTarget] = new WebGLRenderTarget(DEFAULT_CONFIG.textureWidth, DEFAULT_CONFIG.textureHeight, {\n      format: RGBAFormat\n    });\n    this.material.map = this[$renderTarget].texture;\n    this.material.needsUpdate = true;\n    this[$camera] = new OrthographicCamera(-1, 1, 1, -1);\n  }\n\n  get intensity() {\n    return this.material.opacity / BASE_SHADOW_OPACITY;\n  }\n\n  set intensity(intensity) {\n    const intensityIsNumber = typeof intensity === 'number' && !self.isNaN(intensity);\n    this.material.opacity = BASE_SHADOW_OPACITY * (intensityIsNumber ? intensity : 0.0);\n    this.visible = this.material.opacity > 0;\n  }\n  /**\n   * Updates the generated static shadow. The size of the camera is dependent\n   * on the current scale of the StaticShadow that will host the texture.\n   * It's expected for the StaticShadow to be facing the light source.\n   *\n   * @param {THREE.WebGLRenderer} renderer\n   * @param {THREE.Scene} scene\n   * @param {THREE.DirectionalLight} light\n   * @param {Object} config\n   * @param {number} config.near\n   * @param {number} config.far\n   * @param {number} config.textureWidth\n   * @param {number} config.textureHeight\n   */\n\n\n  render(renderer, scene, light, config = {}) {\n    const userSceneOverrideMaterial = scene.overrideMaterial;\n    const userSceneBackground = scene.background;\n    const userClearAlpha = renderer.getClearAlpha();\n    const userRenderTarget = renderer.getRenderTarget();\n    const shadowParent = this.parent;\n    config = Object.assign({}, config, DEFAULT_CONFIG);\n    renderer.setClearAlpha(0);\n    scene.overrideMaterial = shadowGeneratorMaterial;\n    scene.background = null; // Update render target size if necessary\n\n    if (this[$renderTarget].width !== config.textureWidth || this[$renderTarget].height !== config.textureHeight) {\n      this[$renderTarget].setSize(config.textureWidth, config.textureHeight);\n    } // Set the camera to where the light source is,\n    // and facing its target.\n\n\n    light.updateMatrixWorld(true);\n    light.target.updateMatrixWorld(true);\n    this[$camera].position.setFromMatrixPosition(light.matrixWorld);\n    this[$camera].updateMatrixWorld(true);\n    this[$camera].lookAt(light.target.position); // Update the camera's frustum to fully engulf the StaticShadow\n    // mesh that will be rendering the generated texture.\n\n    this.updateMatrixWorld(true);\n    scale.setFromMatrixScale(this.matrixWorld);\n    this[$camera].top = scale.z / 2;\n    this[$camera].bottom = scale.z / -2;\n    this[$camera].left = scale.x / -2;\n    this[$camera].right = scale.x / 2;\n    this[$camera].near = config.near;\n    this[$camera].far = config.far;\n    this[$camera].updateProjectionMatrix(); // There's a chance the shadow will be in the scene that's being rerendered;\n    // temporarily remove it incase.\n\n    if (shadowParent) {\n      shadowParent.remove(this);\n    }\n\n    renderer.setRenderTarget(this[$renderTarget]);\n    renderer.clear();\n    renderer.render(scene, this[$camera]);\n\n    if (shadowParent) {\n      shadowParent.add(this);\n    }\n\n    this.material.needsUpdate = true; // Reset the values on the renderer and scene\n\n    scene.overrideMaterial = userSceneOverrideMaterial;\n    scene.background = userSceneBackground;\n    renderer.setClearAlpha(userClearAlpha);\n    renderer.setRenderTarget(userRenderTarget);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}