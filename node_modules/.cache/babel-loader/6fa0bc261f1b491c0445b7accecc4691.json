{"ast":null,"code":"/*\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Math as ThreeMath, Matrix4, Mesh, MeshBasicMaterial, Object3D, Raycaster, RingGeometry, Vector3 } from 'three';\nconst originArray = new Float32Array(3);\nconst directionArray = new Float32Array(3);\n/**\n * The Reticle class creates an object that repeatedly calls\n * `xrSession.requestHitTest()` to render a ring along a found\n * horizontal surface.\n */\n\nexport default class Reticle extends Object3D {\n  /**\n   * @param {XRSession} xrSession\n   * @param {THREE.Camera} camera\n   */\n  constructor(camera) {\n    super();\n    this.raycaster = null;\n    this.name = 'Reticle';\n    let geometry = new RingGeometry(0.1, 0.11, 24, 1);\n    let material = new MeshBasicMaterial({\n      color: 0xffffff\n    }); // Orient the geometry so its position is flat on a horizontal surface\n\n    geometry.applyMatrix(new Matrix4().makeRotationX(ThreeMath.degToRad(-90)));\n    this.ring = new Mesh(geometry, material);\n    this.add(this.ring);\n    this.visible = false;\n    this.camera = camera;\n  }\n  /**\n   * Fires a hit test in the middle of the screen and places the reticle\n   * upon the surface if found.\n   *\n   * @param {XRSession} session\n   * @param {XRFrameOfReference} frameOfRef\n   */\n\n\n  async update(session, frameOfRef) {\n    this.raycaster = this.raycaster || new Raycaster();\n    this.raycaster.setFromCamera({\n      x: 0,\n      y: 0\n    }, this.camera);\n    const ray = this.raycaster.ray;\n    originArray.set(ray.origin.toArray());\n    directionArray.set(ray.direction.toArray());\n    let hits;\n\n    try {\n      hits = await session.requestHitTest(originArray, directionArray, frameOfRef);\n    } catch (error) {\n      hits = [];\n    }\n\n    if (hits.length) {\n      const hit = hits[0];\n      const hitMatrix = new Matrix4().fromArray(hit.hitMatrix); // Now apply the position from the hitMatrix onto our model\n\n      this.position.setFromMatrixPosition(hitMatrix); // Rotate the anchor to face the camera\n\n      const targetPos = new Vector3().setFromMatrixPosition(this.camera.matrixWorld);\n      const angle = Math.atan2(targetPos.x - this.position.x, targetPos.z - this.position.z);\n      this.rotation.set(0, angle, 0);\n      this.visible = true;\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}