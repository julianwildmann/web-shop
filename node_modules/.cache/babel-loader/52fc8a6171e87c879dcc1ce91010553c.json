{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Module to add shady DOM/shady CSS polyfill support to lit-html template\n * rendering. See the [[render]] method for details.\n *\n * @module shady-render\n * @preferred\n */\n\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\nimport { removeNodes } from './dom.js';\nimport { insertNodeIntoTemplate, removeNodesFromTemplate } from './modify-template.js';\nimport { parts, render as litRender } from './render.js';\nimport { templateCaches } from './template-factory.js';\nimport { TemplateInstance } from './template-instance.js';\nimport { TemplateResult } from './template-result.js';\nimport { marker, Template } from './template.js';\nexport { html, svg, TemplateResult } from '../lit-html.js'; // Get a key to lookup in `templateCaches`.\n\nconst getTemplateCacheKey = (type, scopeName) => \"\".concat(type, \"--\").concat(scopeName);\n\nlet compatibleShadyCSSVersion = true;\n\nif (typeof window.ShadyCSS === 'undefined') {\n  compatibleShadyCSSVersion = false;\n} else if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {\n  console.warn(\"Incompatible ShadyCSS version detected. \" + \"Please update to at least @webcomponents/webcomponentsjs@2.0.2 and \" + \"@webcomponents/shadycss@1.3.1.\");\n  compatibleShadyCSSVersion = false;\n}\n/**\n * Template factory which scopes template DOM using ShadyCSS.\n * @param scopeName {string}\n */\n\n\nconst shadyTemplateFactory = scopeName => result => {\n  const cacheKey = getTemplateCacheKey(result.type, scopeName);\n  let templateCache = templateCaches.get(cacheKey);\n\n  if (templateCache === undefined) {\n    templateCache = {\n      stringsArray: new WeakMap(),\n      keyString: new Map()\n    };\n    templateCaches.set(cacheKey, templateCache);\n  }\n\n  let template = templateCache.stringsArray.get(result.strings);\n\n  if (template !== undefined) {\n    return template;\n  }\n\n  const key = result.strings.join(marker);\n  template = templateCache.keyString.get(key);\n\n  if (template === undefined) {\n    const element = result.getTemplateElement();\n\n    if (compatibleShadyCSSVersion) {\n      window.ShadyCSS.prepareTemplateDom(element, scopeName);\n    }\n\n    template = new Template(result, element);\n    templateCache.keyString.set(key, template);\n  }\n\n  templateCache.stringsArray.set(result.strings, template);\n  return template;\n};\n\nconst TEMPLATE_TYPES = ['html', 'svg'];\n/**\n * Removes all style elements from Templates for the given scopeName.\n */\n\nconst removeStylesFromLitTemplates = scopeName => {\n  TEMPLATE_TYPES.forEach(type => {\n    const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));\n\n    if (templates !== undefined) {\n      templates.keyString.forEach(template => {\n        const content = template.element.content; // IE 11 doesn't support the iterable param Set constructor\n\n        const styles = new Set();\n        Array.from(content.querySelectorAll('style')).forEach(s => {\n          styles.add(s);\n        });\n        removeNodesFromTemplate(template, styles);\n      });\n    }\n  });\n};\n\nconst shadyRenderSet = new Set();\n/**\n * For the given scope name, ensures that ShadyCSS style scoping is performed.\n * This is done just once per scope name so the fragment and template cannot\n * be modified.\n * (1) extracts styles from the rendered fragment and hands them to ShadyCSS\n * to be scoped and appended to the document\n * (2) removes style elements from all lit-html Templates for this scope name.\n *\n * Note, <style> elements can only be placed into templates for the\n * initial rendering of the scope. If <style> elements are included in templates\n * dynamically rendered to the scope (after the first scope render), they will\n * not be scoped and the <style> will be left in the template and rendered\n * output.\n */\n\nconst prepareTemplateStyles = (renderedDOM, template, scopeName) => {\n  shadyRenderSet.add(scopeName); // Move styles out of rendered DOM and store.\n\n  const styles = renderedDOM.querySelectorAll('style');\n  const length = styles.length; // If there are no styles, skip unnecessary work\n\n  if (length === 0) {\n    // Ensure prepareTemplateStyles is called to support adding\n    // styles via `prepareAdoptedCssText` since that requires that\n    // `prepareTemplateStyles` is called.\n    window.ShadyCSS.prepareTemplateStyles(template.element, scopeName);\n    return;\n  }\n\n  const condensedStyle = document.createElement('style'); // Collect styles into a single style. This helps us make sure ShadyCSS\n  // manipulations will not prevent us from being able to fix up template\n  // part indices.\n  // NOTE: collecting styles is inefficient for browsers but ShadyCSS\n  // currently does this anyway. When it does not, this should be changed.\n\n  for (let i = 0; i < length; i++) {\n    const style = styles[i];\n    style.parentNode.removeChild(style);\n    condensedStyle.textContent += style.textContent;\n  } // Remove styles from nested templates in this scope.\n\n\n  removeStylesFromLitTemplates(scopeName); // And then put the condensed style into the \"root\" template passed in as\n  // `template`.\n\n  const content = template.element.content;\n  insertNodeIntoTemplate(template, condensedStyle, content.firstChild); // Note, it's important that ShadyCSS gets the template that `lit-html`\n  // will actually render so that it can update the style inside when\n  // needed (e.g. @apply native Shadow DOM case).\n\n  window.ShadyCSS.prepareTemplateStyles(template.element, scopeName);\n  const style = content.querySelector('style');\n\n  if (window.ShadyCSS.nativeShadow && style !== null) {\n    // When in native Shadow DOM, ensure the style created by ShadyCSS is\n    // included in initially rendered output (`renderedDOM`).\n    renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);\n  } else {\n    // When no style is left in the template, parts will be broken as a\n    // result. To fix this, we put back the style node ShadyCSS removed\n    // and then tell lit to remove that node from the template.\n    // There can be no style in the template in 2 cases (1) when Shady DOM\n    // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM\n    // is in use ShadyCSS removes the style if it contains no content.\n    // NOTE, ShadyCSS creates its own style so we can safely add/remove\n    // `condensedStyle` here.\n    content.insertBefore(condensedStyle, content.firstChild);\n    const removes = new Set();\n    removes.add(condensedStyle);\n    removeNodesFromTemplate(template, removes);\n  }\n};\n/**\n * Extension to the standard `render` method which supports rendering\n * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)\n * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used\n * or when the webcomponentsjs\n * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.\n *\n * Adds a `scopeName` option which is used to scope element DOM and stylesheets\n * when native ShadowDOM is unavailable. The `scopeName` will be added to\n * the class attribute of all rendered DOM. In addition, any style elements will\n * be automatically re-written with this `scopeName` selector and moved out\n * of the rendered DOM and into the document `<head>`.\n *\n * It is common to use this render method in conjunction with a custom element\n * which renders a shadowRoot. When this is done, typically the element's\n * `localName` should be used as the `scopeName`.\n *\n * In addition to DOM scoping, ShadyCSS also supports a basic shim for css\n * custom properties (needed only on older browsers like IE11) and a shim for\n * a deprecated feature called `@apply` that supports applying a set of css\n * custom properties to a given location.\n *\n * Usage considerations:\n *\n * * Part values in `<style>` elements are only applied the first time a given\n * `scopeName` renders. Subsequent changes to parts in style elements will have\n * no effect. Because of this, parts in style elements should only be used for\n * values that will never change, for example parts that set scope-wide theme\n * values or parts which render shared style elements.\n *\n * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a\n * custom element's `constructor` is not supported. Instead rendering should\n * either done asynchronously, for example at microtask timing (for example\n * `Promise.resolve()`), or be deferred until the first time the element's\n * `connectedCallback` runs.\n *\n * Usage considerations when using shimmed custom properties or `@apply`:\n *\n * * Whenever any dynamic changes are made which affect\n * css custom properties, `ShadyCSS.styleElement(element)` must be called\n * to update the element. There are two cases when this is needed:\n * (1) the element is connected to a new parent, (2) a class is added to the\n * element that causes it to match different custom properties.\n * To address the first case when rendering a custom element, `styleElement`\n * should be called in the element's `connectedCallback`.\n *\n * * Shimmed custom properties may only be defined either for an entire\n * shadowRoot (for example, in a `:host` rule) or via a rule that directly\n * matches an element with a shadowRoot. In other words, instead of flowing from\n * parent to child as do native css custom properties, shimmed custom properties\n * flow only from shadowRoots to nested shadowRoots.\n *\n * * When using `@apply` mixing css shorthand property names with\n * non-shorthand names (for example `border` and `border-width`) is not\n * supported.\n */\n\n\nexport const render = (result, container, options) => {\n  const scopeName = options.scopeName;\n  const hasRendered = parts.has(container);\n  const needsScoping = compatibleShadyCSSVersion && container.nodeType === 11\n  /* Node.DOCUMENT_FRAGMENT_NODE */\n  && !!container.host && result instanceof TemplateResult; // Handle first render to a scope specially...\n\n  const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName); // On first scope render, render into a fragment; this cannot be a single\n  // fragment that is reused since nested renders can occur synchronously.\n\n  const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;\n  litRender(result, renderContainer, Object.assign({\n    templateFactory: shadyTemplateFactory(scopeName)\n  }, options)); // When performing first scope render,\n  // (1) We've rendered into a fragment so that there's a chance to\n  // `prepareTemplateStyles` before sub-elements hit the DOM\n  // (which might cause them to render based on a common pattern of\n  // rendering in a custom element's `connectedCallback`);\n  // (2) Scope the template with ShadyCSS one time only for this scope.\n  // (3) Render the fragment into the container and make sure the\n  // container knows its `part` is the one we just rendered. This ensures\n  // DOM will be re-used on subsequent renders.\n\n  if (firstScopeRender) {\n    const part = parts.get(renderContainer);\n    parts.delete(renderContainer);\n\n    if (part.value instanceof TemplateInstance) {\n      prepareTemplateStyles(renderContainer, part.value.template, scopeName);\n    }\n\n    removeNodes(container, container.firstChild);\n    container.appendChild(renderContainer);\n    parts.set(container, part);\n  } // After elements have hit the DOM, update styling if this is the\n  // initial render to this container.\n  // This is needed whenever dynamic changes are made so it would be\n  // safest to do every render; however, this would regress performance\n  // so we leave it up to the user to call `ShadyCSSS.styleElement`\n  // for dynamic changes.\n\n\n  if (!hasRendered && needsScoping) {\n    window.ShadyCSS.styleElement(container.host);\n  }\n};","map":null,"metadata":{},"sourceType":"module"}