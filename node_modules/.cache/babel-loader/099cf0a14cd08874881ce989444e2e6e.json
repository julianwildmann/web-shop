{"ast":null,"code":"/*\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { property } from 'lit-element';\nimport { IS_ANDROID, IS_AR_QUICKLOOK_CANDIDATE, IS_IOS, IS_IOS_CHROME, IS_IOS_SAFARI, IS_WEBXR_AR_CANDIDATE } from '../constants.js';\nimport { enumerationDeserializer } from '../conversions.js';\nimport { $container, $renderer, $scene } from '../model-viewer-base.js';\nimport { deserializeUrl } from '../utilities.js';\n/**\n * Takes a URL to a USDZ file and sets the appropriate fields so that Safari\n * iOS can intent to their AR Quick Look.\n */\n\nexport const openIOSARQuickLook = (() => {\n  const anchor = document.createElement('a');\n  anchor.setAttribute('rel', 'ar');\n  anchor.appendChild(document.createElement('img'));\n  return usdzSrc => {\n    anchor.setAttribute('href', usdzSrc);\n    anchor.click();\n  };\n})();\nexport const openARViewer = (() => {\n  const anchor = document.createElement('a');\n  const noArViewerSigil = '#model-viewer-no-ar-fallback';\n  let fallbackInvoked = false;\n  return (gltfSrc, title) => {\n    // If the fallback has ever been invoked this session, bounce early:\n    if (fallbackInvoked) {\n      return;\n    }\n\n    const location = self.location.toString();\n    const locationUrl = new URL(location);\n    const modelUrl = new URL(gltfSrc);\n    const link = encodeURIComponent(location);\n    const scheme = modelUrl.protocol.replace(':', '');\n    locationUrl.hash = noArViewerSigil;\n    title = encodeURIComponent(title);\n    modelUrl.protocol = 'intent://';\n    const intent = \"\".concat(modelUrl.toString(), \"?link=\").concat(link, \"&title=\").concat(title, \"#Intent;scheme=\").concat(scheme, \";package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=\").concat(encodeURIComponent(locationUrl.toString()), \";end;\");\n\n    const undoHashChange = () => {\n      if (self.location.hash === noArViewerSigil && !fallbackInvoked) {\n        fallbackInvoked = true; // The new history will be the current URL with a new hash.\n        // Go back one step so that we reset to the expected URL.\n        // NOTE(cdata): this should not invoke any browser-level navigation\n        // because hash-only changes modify the URL in-place without\n        // navigating:\n\n        self.history.back();\n      }\n    };\n\n    self.addEventListener('hashchange', undoHashChange, {\n      once: true\n    });\n    anchor.setAttribute('href', intent);\n    anchor.click();\n  };\n})();\nconst deserializeQuickLookBrowsers = enumerationDeserializer(['safari', 'chrome']);\nconst ARMode = {\n  QUICK_LOOK: 'quick-look',\n  AR_VIEWER: 'ar-viewer',\n  UNSTABLE_WEBXR: 'unstable-webxr',\n  NONE: 'none'\n};\nconst $exitFullscreenButtonContainer = Symbol('exitFullscreenButtonContainer');\nconst $arButtonContainer = Symbol('arButtonContainer');\nconst $defaultExitFullscreenButton = Symbol('defaultExitFullscreenButton');\nconst $enterARWithWebXR = Symbol('enterARWithWebXR');\nconst $canActivateAR = Symbol('canActivateAR');\nconst $arMode = Symbol('arMode');\nconst $canLaunchQuickLook = Symbol('canLaunchQuickLook');\nconst $quickLookBrowsers = Symbol('quickLookBrowsers');\nconst $arButtonContainerClickHandler = Symbol('arButtonContainerClickHandler');\nconst $onARButtonContainerClick = Symbol('onARButtonContainerClick');\nconst $exitFullscreenButtonContainerClickHandler = Symbol('exitFullscreenButtonContainerClickHandler');\nconst $onExitFullscreenButtonClick = Symbol('onExitFullscreenButtonClick');\nconst $fullscreenchangeHandler = Symbol('fullscreenHandler');\nconst $onFullscreenchange = Symbol('onFullscreen');\nexport const ARMixin = ModelViewerElement => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n  class ARModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.ar = false;\n      this.unstableWebxr = false;\n      this.iosSrc = null;\n      this.quickLookBrowsers = 'safari';\n      this[_a] = false; // TODO: Add this to the shadow root as part of this mixin's\n      // implementation:\n\n      this[_b] = this.shadowRoot.querySelector('.ar-button');\n      this[_c] = this.shadowRoot.querySelector('.slot.exit-fullscreen-button');\n      this[_d] = this.shadowRoot.querySelector('#default-exit-fullscreen-button');\n\n      this[_e] = event => this[$onARButtonContainerClick](event);\n\n      this[_f] = () => this[$onExitFullscreenButtonClick]();\n\n      this[_g] = () => this[$onFullscreenchange]();\n\n      this[_h] = ARMode.NONE;\n      this[_j] = new Set();\n    }\n\n    get canActivateAR() {\n      return this[$arMode] !== ARMode.NONE;\n    }\n    /**\n     * Activates AR. Note that for any mode that is not WebXR-based, this\n     * method most likely has to be called synchronous from a user\n     * interaction handler. Otherwise, attempts to activate modes that\n     * require user interaction will most likely be ignored.\n     */\n\n\n    async activateAR() {\n      switch (this[$arMode]) {\n        case ARMode.QUICK_LOOK:\n          openIOSARQuickLook(this.iosSrc);\n          break;\n\n        case ARMode.UNSTABLE_WEBXR:\n          await this[$enterARWithWebXR]();\n          break;\n\n        case ARMode.AR_VIEWER:\n          this.requestFullscreen();\n          openARViewer(this.src, this.alt || '');\n          break;\n\n        default:\n          console.warn('No AR Mode can be activated. This is probably due to missing \\\nconfiguration or device capabilities');\n          break;\n      }\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n      document.addEventListener('fullscreenchange', this[$fullscreenchangeHandler]);\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      document.removeEventListener('fullscreenchange', this[$fullscreenchangeHandler]);\n    }\n\n    [(_a = $canActivateAR, _b = $arButtonContainer, _c = $exitFullscreenButtonContainer, _d = $defaultExitFullscreenButton, _e = $arButtonContainerClickHandler, _f = $exitFullscreenButtonContainerClickHandler, _g = $fullscreenchangeHandler, _h = $arMode, _j = $quickLookBrowsers, $onExitFullscreenButtonClick)]() {\n      if (document.fullscreenElement === this) {\n        document.exitFullscreen();\n      }\n    }\n\n    [$onFullscreenchange]() {\n      const renderer = this[$renderer];\n      const scene = this[$scene];\n      const isFullscreen = document.fullscreenElement === this;\n\n      if (isFullscreen) {\n        this[$container].classList.add('fullscreen');\n      } else {\n        this[$container].classList.remove('fullscreen');\n      }\n\n      if (document.fullscreenElement !== this && renderer.presentedScene === scene) {\n        try {\n          renderer.stopPresenting();\n        } catch (error) {\n          console.warn('Unexpected error while stopping AR presentation');\n          console.error(error);\n        }\n      }\n    }\n\n    async [$enterARWithWebXR]() {\n      const renderer = this[$renderer];\n      console.log('Attempting to enter fullscreen and present in AR...');\n\n      try {\n        const enterFullscreen = this.requestFullscreen();\n\n        try {\n          const outputElement = await renderer.present(this[$scene]);\n          this.shadowRoot.appendChild(outputElement);\n          await enterFullscreen;\n        } catch (error) {\n          console.warn('Error while trying to present to AR');\n          console.error(error);\n          await enterFullscreen;\n\n          if (document.fullscreenElement === this) {\n            console.warn('Exiting fullscreen under dire circumstances');\n            document.exitFullscreen();\n          }\n        }\n      } catch (error) {\n        console.error(error);\n        console.warn('AR will not activate without fullscreen permission');\n      }\n    }\n\n    async update(changedProperties) {\n      super.update(changedProperties);\n\n      if (changedProperties.has('quickLookBrowsers')) {\n        this[$quickLookBrowsers] = deserializeQuickLookBrowsers(this.quickLookBrowsers);\n      }\n\n      if (!changedProperties.has('unstableWebxr') && !changedProperties.has('iosSrc') && !changedProperties.has('ar') && !changedProperties.has('src') && !changedProperties.has('alt')) {\n        return;\n      }\n\n      const renderer = this[$renderer];\n      const unstableWebxrCandidate = this.unstableWebxr && IS_WEBXR_AR_CANDIDATE && (await renderer.supportsPresentation());\n      const arViewerCandidate = IS_ANDROID && this.ar;\n      const iosQuickLookCandidate = IS_IOS && IS_AR_QUICKLOOK_CANDIDATE && this[$canLaunchQuickLook] && !!this.iosSrc;\n      const showArButton = unstableWebxrCandidate || arViewerCandidate || iosQuickLookCandidate;\n\n      if (unstableWebxrCandidate) {\n        this[$arMode] = ARMode.UNSTABLE_WEBXR;\n      } else if (arViewerCandidate) {\n        this[$arMode] = ARMode.AR_VIEWER;\n      } else if (iosQuickLookCandidate) {\n        this[$arMode] = ARMode.QUICK_LOOK;\n      } else {\n        this[$arMode] = ARMode.NONE;\n      }\n\n      if (showArButton) {\n        this[$arButtonContainer].classList.add('enabled');\n        this[$arButtonContainer].addEventListener('click', this[$arButtonContainerClickHandler]);\n        this[$exitFullscreenButtonContainer].addEventListener('click', this[$exitFullscreenButtonContainerClickHandler]);\n      } else {\n        this[$arButtonContainer].removeEventListener('click', this[$arButtonContainerClickHandler]);\n        this[$exitFullscreenButtonContainer].removeEventListener('click', this[$exitFullscreenButtonContainerClickHandler]);\n        this[$arButtonContainer].classList.remove('enabled');\n      }\n    }\n\n    [$onARButtonContainerClick](event) {\n      event.preventDefault();\n      this.activateAR();\n    }\n\n    get [$canLaunchQuickLook]() {\n      if (IS_IOS_CHROME) {\n        return this[$quickLookBrowsers].has('chrome');\n      } else if (IS_IOS_SAFARI) {\n        return this[$quickLookBrowsers].has('safari');\n      }\n\n      return false;\n    }\n\n  }\n\n  __decorate([property({\n    type: Boolean,\n    attribute: 'ar'\n  })], ARModelViewerElement.prototype, \"ar\", void 0);\n\n  __decorate([property({\n    type: Boolean,\n    attribute: 'unstable-webxr'\n  })], ARModelViewerElement.prototype, \"unstableWebxr\", void 0);\n\n  __decorate([property({\n    converter: {\n      fromAttribute: deserializeUrl\n    },\n    attribute: 'ios-src'\n  })], ARModelViewerElement.prototype, \"iosSrc\", void 0);\n\n  __decorate([property({\n    type: String,\n    attribute: 'quick-look-browsers'\n  })], ARModelViewerElement.prototype, \"quickLookBrowsers\", void 0);\n\n  return ARModelViewerElement;\n};","map":null,"metadata":{},"sourceType":"module"}