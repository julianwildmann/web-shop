{"ast":null,"code":"/*\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\n\nimport { clamp } from '../utilities.js';\nconst $ongoingActivities = Symbol('ongoingActivities');\nconst $announceTotalProgress = Symbol('announceTotalProgress');\nconst $eventDelegate = Symbol('eventDelegate');\nconst ACTIVITY_PROGRESS_WEIGHT = 0.5;\n/**\n * ProgressTracker is an event emitter that helps to track the ongoing progress\n * of many simultaneous actions.\n *\n * ProgressTracker reports progress activity in the form of a progress event.\n * The event.detail.totalProgress value indicates the elapsed progress of all\n * activities being tracked by the ProgressTracker.\n *\n * The value of totalProgress is a number that progresses from 0 to 1. The\n * ProgressTracker allows for the lazy accumulation of tracked actions, so the\n * total progress represents a abstract, non-absolute progress towards the\n * completion of all currently tracked events.\n *\n * When all currently tracked activities are finished, the ProgressTracker\n * emits one final progress event and then resets the list of its currently\n * tracked activities. This means that from an observer's perspective,\n * ongoing activities will accumulate and collectively contribute to the notion\n * of total progress until all currently tracked ongoing activities have\n * completed.\n */\n\nexport class ProgressTracker {\n  constructor() {\n    // NOTE(cdata): This eventDelegate hack is a quick trick to let us get the\n    // EventTarget interface without implementing or requiring a full polyfill. We\n    // should remove this once EventTarget is inheritable everywhere.\n    this[_a] = document.createDocumentFragment(); // NOTE(cdata): We declare each of these methods independently here so that we\n    // can inherit the correct types from EventTarget's interface. Maybe there is\n    // a better way to do this dynamically so that we don't repeat ourselves?\n\n    this.addEventListener = (...args) => this[$eventDelegate].addEventListener(...args);\n\n    this.removeEventListener = (...args) => this[$eventDelegate].removeEventListener(...args);\n\n    this.dispatchEvent = (...args) => this[$eventDelegate].dispatchEvent(...args);\n\n    this[_b] = new Set();\n  }\n  /**\n   * The total number of activities currently being tracked.\n   */\n\n\n  get ongoingActivityCount() {\n    return this[$ongoingActivities].size;\n  }\n  /**\n   * Registers a new activity to be tracked by the progress tracker. The method\n   * returns a special callback that should be invoked whenever new progress is\n   * ready to be reported. The progress should be reported as a value between 0\n   * and 1, where 0 would represent the beginning of the action and 1 would\n   * represent its completion.\n   *\n   * There is no built-in notion of a time-out for ongoing activities, so once\n   * an ongoing activity is begun, it is up to the consumer of this API to\n   * update the progress until that activity is no longer ongoing.\n   *\n   * Progress is only allowed to move forward for any given activity. If a lower\n   * progress is reported than the previously reported progress, it will be\n   * ignored.\n   */\n\n\n  beginActivity() {\n    const activity = {\n      progress: 0\n    };\n    this[$ongoingActivities].add(activity);\n\n    if (this.ongoingActivityCount === 1) {\n      // Announce the first progress event (which should always be 0 / 1\n      // total progress):\n      this[$announceTotalProgress]();\n    }\n\n    return progress => {\n      let nextProgress;\n      nextProgress = Math.max(clamp(progress, 0, 1), activity.progress);\n\n      if (nextProgress !== activity.progress) {\n        activity.progress = nextProgress;\n        this[$announceTotalProgress]();\n      }\n\n      return activity.progress;\n    };\n  }\n\n  [(_a = $eventDelegate, _b = $ongoingActivities, $announceTotalProgress)]() {\n    let totalProgress = 0;\n    let statusCount = 0;\n    let completedActivities = 0;\n\n    for (const activity of this[$ongoingActivities]) {\n      const progress = activity.progress;\n      const compoundWeight = ACTIVITY_PROGRESS_WEIGHT / Math.pow(2, statusCount++);\n      totalProgress += progress * compoundWeight;\n\n      if (progress === 1.0) {\n        completedActivities++;\n      }\n    }\n\n    if (completedActivities === this.ongoingActivityCount) {\n      totalProgress = 1.0;\n      this[$ongoingActivities].clear();\n    }\n\n    this.dispatchEvent(new CustomEvent('progress', {\n      detail: {\n        totalProgress\n      }\n    }));\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}