{"ast":null,"code":"/*\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { property } from 'lit-element';\nimport { Color } from 'three';\nimport { $container, $needsRender, $onModelLoad, $progressTracker, $renderer, $scene } from '../model-viewer-base.js';\nimport { IlluminationRole } from '../three-components/ModelScene.js';\nimport { deserializeUrl } from '../utilities.js';\nconst DEFAULT_BACKGROUND_COLOR = '#ffffff';\nconst DEFAULT_SHADOW_INTENSITY = 0.0;\nconst DEFAULT_EXPOSURE = 1.0;\nconst DEFAULT_STAGE_LIGHT_INTENSITY = 1.0;\nconst DEFAULT_ENVIRONMENT_INTENSITY = 1.0;\nconst $currentEnvironmentMap = Symbol('currentEnvironmentMap');\nconst $applyEnvironmentMap = Symbol('applyEnvironmentMap');\nconst $deallocateTextures = Symbol('deallocateTextures');\nconst $updateLighting = Symbol('updateLighting');\nconst $updateToneMapping = Symbol('updateToneMapping');\nconst $updateShadow = Symbol('updateShadow');\nconst $updateEnvironment = Symbol('updateEnvironment');\nconst $cancelEnvironmentUpdate = Symbol('cancelEnvironmentUpdate');\nexport const EnvironmentMixin = ModelViewerElement => {\n  var _a, _b;\n\n  class EnvironmentModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.environmentImage = null;\n      this.environmentIntensity = DEFAULT_ENVIRONMENT_INTENSITY;\n      this.backgroundImage = null;\n      this.backgroundColor = DEFAULT_BACKGROUND_COLOR;\n      this.experimentalPmrem = false;\n      this.shadowIntensity = DEFAULT_SHADOW_INTENSITY;\n      this.stageLightIntensity = DEFAULT_STAGE_LIGHT_INTENSITY;\n      this.exposure = DEFAULT_EXPOSURE;\n      this[_a] = null;\n      this[_b] = null;\n    }\n\n    updated(changedProperties) {\n      super.updated(changedProperties);\n\n      if (changedProperties.has('shadowIntensity')) {\n        this[$updateShadow]();\n      }\n\n      if (changedProperties.has('exposure')) {\n        this[$updateToneMapping]();\n      }\n\n      if (changedProperties.has('environmentIntensity') || changedProperties.has('stageLightIntensity')) {\n        this[$updateLighting]();\n      }\n\n      if (changedProperties.has('environmentImage') || changedProperties.has('backgroundImage') || changedProperties.has('backgroundColor') || changedProperties.has('experimentalPmrem')) {\n        this[$updateEnvironment]();\n      }\n    }\n\n    firstUpdated(changedProperties) {\n      super.firstUpdated && super.firstUpdated(changedProperties); // In case no environment-related properties were confiured, we should\n      // make sure that the environment is updated at least once:\n\n      if (this[$cancelEnvironmentUpdate] == null) {\n        this[$updateEnvironment]();\n      }\n    }\n\n    [(_a = $currentEnvironmentMap, _b = $cancelEnvironmentUpdate, $onModelLoad)](event) {\n      super[$onModelLoad](event);\n\n      if (this[$currentEnvironmentMap] != null) {\n        this[$applyEnvironmentMap](this[$currentEnvironmentMap]);\n      }\n    }\n\n    async [$updateEnvironment]() {\n      const backgroundImage = this.backgroundImage,\n            environmentImage = this.environmentImage,\n            pmrem = this.experimentalPmrem;\n      let backgroundColor = this.backgroundColor;\n\n      if (this[$cancelEnvironmentUpdate] != null) {\n        this[$cancelEnvironmentUpdate]();\n        this[$cancelEnvironmentUpdate] = null;\n      }\n\n      const textureUtils = this[$renderer].textureUtils;\n\n      if (textureUtils == null) {\n        return;\n      }\n\n      try {\n        const _ref = await new Promise(async (resolve, reject) => {\n          const texturesLoad = textureUtils.generateEnvironmentMapAndSkybox(backgroundImage, environmentImage, {\n            pmrem,\n            progressTracker: this[$progressTracker]\n          });\n\n          this[$cancelEnvironmentUpdate] = () => reject(texturesLoad);\n\n          resolve((await texturesLoad));\n        }),\n              environmentMap = _ref.environmentMap,\n              skybox = _ref.skybox;\n\n        this[$deallocateTextures]();\n\n        if (skybox != null) {\n          this[$scene].background = skybox;\n        } else {\n          if (!backgroundColor) {\n            backgroundColor = DEFAULT_BACKGROUND_COLOR;\n          }\n\n          const parsedColor = new Color(backgroundColor);\n          this[$scene].background = parsedColor; // Set the container node's background color so that it matches\n          // the background color configured for the scene. It's important\n          // to do this because we round the size of the canvas off to the\n          // nearest pixel, so it is possible (indeed likely) that there is\n          // a marginal gap around one or two edges of the canvas.\n\n          this[$container].style.backgroundColor = backgroundColor;\n        }\n\n        this[$applyEnvironmentMap](environmentMap);\n      } catch (errorOrPromise) {\n        if (errorOrPromise instanceof Error) {\n          this[$applyEnvironmentMap](null);\n          throw errorOrPromise;\n        }\n\n        const _ref2 = await errorOrPromise,\n              environmentMap = _ref2.environmentMap,\n              skybox = _ref2.skybox;\n\n        if (environmentMap != null) {\n          environmentMap.dispose();\n        }\n\n        if (skybox != null) {\n          skybox.dispose();\n        }\n      }\n    }\n    /**\n     * Sets the Model to use the provided environment map,\n     * or `null` if the Model should remove its' environment map.\n     *\n     * @param {THREE.Texture} environmentMap\n     */\n\n\n    [$applyEnvironmentMap](environmentMap) {\n      this[$currentEnvironmentMap] = environmentMap;\n      this[$scene].model.applyEnvironmentMap(this[$currentEnvironmentMap]);\n      this.dispatchEvent(new CustomEvent('environment-change'));\n      this[$updateLighting]();\n      this[$needsRender]();\n    }\n\n    [$updateShadow]() {\n      this[$scene].shadow.intensity = this.shadowIntensity;\n      this[$needsRender]();\n    }\n\n    [$updateToneMapping]() {\n      this[$scene].exposure = this.exposure;\n      this[$needsRender]();\n    }\n\n    [$updateLighting]() {\n      const scene = this[$scene];\n      const illuminationRole = this.experimentalPmrem ? IlluminationRole.Secondary : IlluminationRole.Primary;\n      const environmentIntensity = this.experimentalPmrem ? this.environmentIntensity * 0.65 : this.environmentIntensity;\n      scene.configureStageLighting(this.stageLightIntensity, illuminationRole);\n      scene.model.setEnvironmentMapIntensity(environmentIntensity);\n    }\n\n    [$deallocateTextures]() {\n      const background = this[$scene].background;\n\n      if (background && background.dispose) {\n        background.dispose();\n      }\n\n      if (this[$currentEnvironmentMap]) {\n        this[$currentEnvironmentMap].dispose();\n        this[$currentEnvironmentMap] = null;\n      }\n    }\n\n  }\n\n  __decorate([property({\n    type: String,\n    attribute: 'environment-image',\n    converter: {\n      fromAttribute: deserializeUrl\n    }\n  })], EnvironmentModelViewerElement.prototype, \"environmentImage\", void 0);\n\n  __decorate([property({\n    type: Number,\n    attribute: 'environment-intensity'\n  })], EnvironmentModelViewerElement.prototype, \"environmentIntensity\", void 0);\n\n  __decorate([property({\n    type: String,\n    attribute: 'background-image',\n    converter: {\n      fromAttribute: deserializeUrl\n    }\n  })], EnvironmentModelViewerElement.prototype, \"backgroundImage\", void 0);\n\n  __decorate([property({\n    type: String,\n    attribute: 'background-color'\n  })], EnvironmentModelViewerElement.prototype, \"backgroundColor\", void 0);\n\n  __decorate([property({\n    type: Boolean,\n    attribute: 'experimental-pmrem'\n  })], EnvironmentModelViewerElement.prototype, \"experimentalPmrem\", void 0);\n\n  __decorate([property({\n    type: Number,\n    attribute: 'shadow-intensity'\n  })], EnvironmentModelViewerElement.prototype, \"shadowIntensity\", void 0);\n\n  __decorate([property({\n    type: Number,\n    attribute: 'stage-light-intensity'\n  })], EnvironmentModelViewerElement.prototype, \"stageLightIntensity\", void 0);\n\n  __decorate([property({\n    type: Number\n  })], EnvironmentModelViewerElement.prototype, \"exposure\", void 0);\n\n  return EnvironmentModelViewerElement;\n};","map":null,"metadata":{},"sourceType":"module"}