{"ast":null,"code":"/*\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a;\n\nimport { Cache, EventDispatcher, GammaEncoding, NearestFilter, RGBEEncoding, TextureLoader } from 'three';\nimport { PMREMCubeUVPacker } from 'three/examples/jsm/pmrem/PMREMCubeUVPacker.js';\nimport { PMREMGenerator } from 'three/examples/jsm/pmrem/PMREMGenerator.js';\nimport { EquirectangularToCubeGenerator } from '../third_party/three/EquirectangularToCubeGenerator.js';\nimport { RGBELoader } from '../third_party/three/RGBELoader.js';\nimport EnvironmentMapGenerator from './EnvironmentMapGenerator.js'; // Enable three's loader cache so we don't create redundant\n// Image objects to decode images fetched over the network.\n\nCache.enabled = true;\nconst HDR_FILE_RE = /\\.hdr$/;\nconst ldrLoader = new TextureLoader();\nconst hdrLoader = new RGBELoader();\nconst $cubeGenerator = Symbol('cubeGenerator');\nconst defaultConfig = {\n  cubemapSize: 1024\n}; // Attach a `userData` object for arbitrary data on textures that\n// originate from TextureUtils, similar to Object3D's userData,\n// for help debugging, providing metadata for tests, and semantically\n// describe the type of texture within the context of this application.\n\nconst userData = {\n  url: null,\n  // 'Equirectangular', 'Cube', 'PMREM'\n  mapping: null\n};\nexport default class TextureUtils extends EventDispatcher {\n  /**\n   * @param {THREE.WebGLRenderer} renderer\n   * @param {?number} config.cubemapSize\n   */\n  constructor(renderer, config = {}) {\n    super();\n    this[_a] = null;\n    this.config = Object.assign({}, defaultConfig, config);\n    this.renderer = renderer;\n    this.environmentMapGenerator = new EnvironmentMapGenerator(this.renderer);\n  }\n  /**\n   * @param {THREE.Texture} texture\n   * @return {THREE.WebGLRenderCubeTarget}\n   */\n\n\n  equirectangularToCubemap(texture) {\n    const generator = new EquirectangularToCubeGenerator(texture, {\n      resolution: this.config.cubemapSize\n    });\n    generator.update(this.renderer);\n    generator.renderTarget.texture.userData = Object.assign({}, userData, {\n      url: texture.userData ? texture.userData.url : null,\n      mapping: 'Cube'\n    }); // It's up to the previously served texture to dispose itself,\n    // and therefore the generator's render target.\n\n    this[$cubeGenerator] = generator;\n    return generator.renderTarget;\n  }\n  /**\n   * @param {string} url\n   * @param {Function} progressCallback\n   * @return {Promise<THREE.Texture>}\n   */\n\n\n  async load(url, progressCallback = () => {}) {\n    try {\n      const isHDR = HDR_FILE_RE.test(url);\n      const loader = isHDR ? hdrLoader : ldrLoader;\n      const texture = await new Promise((resolve, reject) => loader.load(url, resolve, event => {\n        progressCallback(event.loaded / event.total * 0.9);\n      }, reject));\n      progressCallback(1.0);\n      texture.userData = Object.assign({}, userData, {\n        url: url,\n        mapping: 'Equirectangular'\n      });\n\n      if (isHDR) {\n        texture.encoding = RGBEEncoding;\n        texture.minFilter = NearestFilter;\n        texture.magFilter = NearestFilter;\n        texture.flipY = true;\n      } else {\n        texture.encoding = GammaEncoding;\n      }\n\n      return texture;\n    } finally {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n    }\n  }\n  /**\n   * @param {string} url\n   * @param {Function} progressCallback\n   * @return {Promise<THREE.WebGLRenderCubeTarget>}\n   */\n\n\n  async loadEquirectAsCubeMap(url, progressCallback = () => {}) {\n    let equirect = null;\n\n    try {\n      equirect = await this.load(url, progressCallback);\n      return await this.equirectangularToCubemap(equirect);\n    } finally {\n      if (equirect != null) {\n        equirect.dispose();\n      }\n    }\n  }\n  /**\n   * Returns a { skybox, environmentMap } object with the targets/textures\n   * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n   * is a Texture from a WebGLRenderCubeTarget.\n   *\n   * @see equirectangularToCubemap with regard to the THREE types.\n   * @param {string} url\n   * @param {boolean} config.pmrem\n   * @param {ProgressTracker} config.progressTracker\n   * @return {Promise<Object|null>}\n   */\n\n\n  async generateEnvironmentMapAndSkybox(skyboxUrl = null, environmentMapUrl = null, options = {}) {\n    const progressTracker = options.progressTracker;\n\n    let updateGenerationProgress = () => {};\n\n    let skyboxLoads = Promise.resolve(null);\n    let environmentMapLoads = Promise.resolve(null);\n    let skybox = null;\n    let environmentMap = null;\n\n    try {\n      let environmentMapWasGenerated = false; // If we have a specific environment URL, attempt to load it as a cubemap\n      // The case for this is that the user intends for the IBL to be different\n      // from the scene background (which may be a skybox or solid color).\n\n      if (!!environmentMapUrl) {\n        environmentMapLoads = this.loadEquirectAsCubeMap(environmentMapUrl, progressTracker ? progressTracker.beginActivity() : () => {});\n      } // If we have a skybox URL, attempt to load it as a cubemap\n\n\n      if (!!skyboxUrl) {\n        skyboxLoads = this.loadEquirectAsCubeMap(skyboxUrl, progressTracker ? progressTracker.beginActivity() : () => {});\n      }\n\n      updateGenerationProgress = progressTracker ? progressTracker.beginActivity() : () => {}; // In practice, this should be nearly as parallel as Promise.all (which\n      // we don't use since we can't easily destructure here):\n\n      environmentMap = await environmentMapLoads;\n      skybox = await skyboxLoads; // If environment is still null, then no specific environment URL was\n      // specified\n\n      if (environmentMap != null) {\n        environmentMap = environmentMap.texture;\n      } else {\n        if (skybox != null) {\n          // Infer the environment from the skybox if we have one:\n          environmentMap = skybox.texture;\n        } else {\n          // Otherwise, no skybox URL was specified, so fall back to generating\n          // the environment:\n          // TODO(#336): can cache this per renderer and color\n          environmentMap = this.environmentMapGenerator.generate();\n          environmentMapWasGenerated = true;\n        }\n      }\n\n      if (options.pmrem) {\n        // Apply the PMREM pass to the environment, which produces a distinct\n        // texture from the source:\n        const nonPmremEnvironmentMap = environmentMap;\n        environmentMap = this.pmremPass(nonPmremEnvironmentMap); // If the source was generated, then we should dispose of it right away\n\n        if (environmentMapWasGenerated) {\n          nonPmremEnvironmentMap.dispose();\n        }\n      } else if (environmentMapWasGenerated) {\n        environmentMap.userData = Object.assign({}, userData, {\n          mapping: 'Cube'\n        });\n      }\n\n      return {\n        environmentMap,\n        skybox\n      };\n    } catch (error) {\n      if (skybox != null) {\n        skybox.dispose();\n      }\n\n      if (environmentMap != null) {\n        environmentMap.dispose();\n      }\n\n      throw error;\n    } finally {\n      updateGenerationProgress(1.0);\n    }\n  }\n  /**\n   * Takes a cube-ish (@see equirectangularToCubemap) texture and\n   * returns a texture of the prefiltered mipmapped radiance environment map\n   * to be used as environment maps in models.\n   *\n   * @param {THREE.Texture} texture\n   * @param {number} samples\n   * @param {number} resolution\n   * @return {THREE.Texture}\n   */\n\n\n  pmremPass(texture, samples, size) {\n    const generator = new PMREMGenerator(texture, samples, size);\n    generator.update(this.renderer);\n    const packer = new PMREMCubeUVPacker(generator.cubeLods);\n    packer.update(this.renderer);\n    const renderTarget = packer.CubeUVRenderTarget;\n    generator.dispose();\n    packer.dispose();\n    renderTarget.texture.userData = Object.assign({}, userData, {\n      url: texture.userData ? texture.userData.url : null,\n      mapping: 'PMREM'\n    });\n    return renderTarget.texture;\n  }\n\n  dispose() {\n    // NOTE(cdata): In the case that the generators are invoked with\n    // an incorrect texture, the generators will throw when we attempt to\n    // dispose of them because the framebuffer has not been created yet but the\n    // implementation does not guard for this correctly:\n    try {\n      this.environmentMapGenerator.dispose();\n      this.environmentMapGenerator = null;\n\n      if (this[$cubeGenerator] != null) {\n        this[$cubeGenerator].dispose();\n        this[$cubeGenerator] = null;\n      }\n    } catch (_error) {}\n  }\n\n}\n_a = $cubeGenerator;","map":null,"metadata":{},"sourceType":"module"}