{"ast":null,"code":"/**\n * @author Prashant Sharma / spidersharma03\n * @author Ben Houston / bhouston, https://clara.io\n *\n * To avoid cube map seams, I create an extra pixel around each face. This way when the cube map is\n * sampled by an application later(with a little care by sampling the centre of the texel), the extra 1 border\n *\tof pixels makes sure that there is no seams artifacts present. This works perfectly for cubeUV format as\n *\twell where the 6 faces can be arranged in any manner whatsoever.\n * Code in the beginning of fragment shader's main function does this job for a given resolution.\n *\tRun Scene_PMREM_Test.html in the examples directory to see the sampling from the cube lods generated\n *\tby this class.\n */\nimport { DoubleSide, GammaEncoding, LinearEncoding, LinearFilter, LinearToneMapping, Mesh, NearestFilter, NoBlending, OrthographicCamera, PlaneBufferGeometry, Scene, ShaderMaterial, WebGLRenderTargetCube, sRGBEncoding } from \"../../../build/three.module.js\";\n\nvar PMREMGenerator = function () {\n  var shader = getShader();\n  var camera = new OrthographicCamera(-1, 1, 1, -1, 0.0, 1000);\n  var scene = new Scene();\n  var planeMesh = new Mesh(new PlaneBufferGeometry(2, 2, 0), shader);\n  planeMesh.material.side = DoubleSide;\n  scene.add(planeMesh);\n  scene.add(camera);\n\n  var PMREMGenerator = function (sourceTexture, samplesPerLevel, resolution) {\n    this.sourceTexture = sourceTexture;\n    this.resolution = resolution !== undefined ? resolution : 256; // NODE: 256 is currently hard coded in the glsl code for performance reasons\n\n    this.samplesPerLevel = samplesPerLevel !== undefined ? samplesPerLevel : 32;\n    var monotonicEncoding = this.sourceTexture.encoding === LinearEncoding || this.sourceTexture.encoding === GammaEncoding || this.sourceTexture.encoding === sRGBEncoding;\n    this.sourceTexture.minFilter = monotonicEncoding ? LinearFilter : NearestFilter;\n    this.sourceTexture.magFilter = monotonicEncoding ? LinearFilter : NearestFilter;\n    this.sourceTexture.generateMipmaps = this.sourceTexture.generateMipmaps && monotonicEncoding;\n    this.cubeLods = [];\n    var size = this.resolution;\n    var params = {\n      format: this.sourceTexture.format,\n      magFilter: this.sourceTexture.magFilter,\n      minFilter: this.sourceTexture.minFilter,\n      type: this.sourceTexture.type,\n      generateMipmaps: this.sourceTexture.generateMipmaps,\n      anisotropy: this.sourceTexture.anisotropy,\n      encoding: this.sourceTexture.encoding\n    }; // how many LODs fit in the given CubeUV Texture.\n\n    this.numLods = Math.log(size) / Math.log(2) - 2; // IE11 doesn't support Math.log2\n\n    for (var i = 0; i < this.numLods; i++) {\n      var renderTarget = new WebGLRenderTargetCube(size, size, params);\n      renderTarget.texture.name = \"PMREMGenerator.cube\" + i;\n      this.cubeLods.push(renderTarget);\n      size = Math.max(16, size / 2);\n    }\n  };\n\n  PMREMGenerator.prototype = {\n    constructor: PMREMGenerator,\n\n    /*\n     * Prashant Sharma / spidersharma03: More thought and work is needed here.\n     * Right now it's a kind of a hack to use the previously convolved map to convolve the current one.\n     * I tried to use the original map to convolve all the lods, but for many textures(specially the high frequency)\n     * even a high number of samples(1024) dosen't lead to satisfactory results.\n     * By using the previous convolved maps, a lower number of samples are generally sufficient(right now 32, which\n     * gives okay results unless we see the reflection very carefully, or zoom in too much), however the math\n     * goes wrong as the distribution function tries to sample a larger area than what it should be. So I simply scaled\n     * the roughness by 0.9(totally empirical) to try to visually match the original result.\n     * The condition \"if(i <5)\" is also an attemt to make the result match the original result.\n     * This method requires the most amount of thinking I guess. Here is a paper which we could try to implement in future::\n     * https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch20.html\n     */\n    update: function (renderer) {\n      // Texture should only be flipped for CubeTexture, not for\n      // a Texture created via WebGLRenderTargetCube.\n      var tFlip = this.sourceTexture.isCubeTexture ? -1 : 1;\n      shader.defines['SAMPLES_PER_LEVEL'] = this.samplesPerLevel;\n      shader.uniforms['faceIndex'].value = 0;\n      shader.uniforms['envMap'].value = this.sourceTexture;\n      shader.envMap = this.sourceTexture;\n      shader.needsUpdate = true;\n      var gammaInput = renderer.gammaInput;\n      var gammaOutput = renderer.gammaOutput;\n      var toneMapping = renderer.toneMapping;\n      var toneMappingExposure = renderer.toneMappingExposure;\n      var currentRenderTarget = renderer.getRenderTarget();\n      renderer.toneMapping = LinearToneMapping;\n      renderer.toneMappingExposure = 1.0;\n      renderer.gammaInput = false;\n      renderer.gammaOutput = false;\n\n      for (var i = 0; i < this.numLods; i++) {\n        var r = i / (this.numLods - 1);\n        shader.uniforms['roughness'].value = r * 0.9; // see comment above, pragmatic choice\n        // Only apply the tFlip for the first LOD\n\n        shader.uniforms['tFlip'].value = i == 0 ? tFlip : 1;\n        var size = this.cubeLods[i].width;\n        shader.uniforms['mapSize'].value = size;\n        this.renderToCubeMapTarget(renderer, this.cubeLods[i]);\n        if (i < 5) shader.uniforms['envMap'].value = this.cubeLods[i].texture;\n      }\n\n      renderer.setRenderTarget(currentRenderTarget);\n      renderer.toneMapping = toneMapping;\n      renderer.toneMappingExposure = toneMappingExposure;\n      renderer.gammaInput = gammaInput;\n      renderer.gammaOutput = gammaOutput;\n    },\n    renderToCubeMapTarget: function (renderer, renderTarget) {\n      for (var i = 0; i < 6; i++) {\n        this.renderToCubeMapTargetFace(renderer, renderTarget, i);\n      }\n    },\n    renderToCubeMapTargetFace: function (renderer, renderTarget, faceIndex) {\n      shader.uniforms['faceIndex'].value = faceIndex;\n      renderer.setRenderTarget(renderTarget, faceIndex);\n      renderer.clear();\n      renderer.render(scene, camera);\n    },\n    dispose: function () {\n      for (var i = 0, l = this.cubeLods.length; i < l; i++) {\n        this.cubeLods[i].dispose();\n      }\n    }\n  };\n\n  function getShader() {\n    var shaderMaterial = new ShaderMaterial({\n      defines: {\n        \"SAMPLES_PER_LEVEL\": 20\n      },\n      uniforms: {\n        \"faceIndex\": {\n          value: 0\n        },\n        \"roughness\": {\n          value: 0.5\n        },\n        \"mapSize\": {\n          value: 0.5\n        },\n        \"envMap\": {\n          value: null\n        },\n        \"tFlip\": {\n          value: -1\n        }\n      },\n      vertexShader: \"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n      fragmentShader: \"#include <common>\\n\\\n\t\t\t\tvarying vec2 vUv;\\n\\\n\t\t\t\tuniform int faceIndex;\\n\\\n\t\t\t\tuniform float roughness;\\n\\\n\t\t\t\tuniform samplerCube envMap;\\n\\\n\t\t\t\tuniform float mapSize;\\n\\\n\t\t\t\tuniform float tFlip;\\n\\\n\t\t\t\t\\n\\\n\t\t\t\tfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\\n\t\t\t\t\tfloat a = ggxRoughness + 0.0001;\\n\\\n\t\t\t\t\ta *= a;\\n\\\n\t\t\t\t\treturn ( 2.0 / a - 2.0 );\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\tvec3 ImportanceSamplePhong(vec2 uv, mat3 vecSpace, float specPow) {\\n\\\n\t\t\t\t\tfloat phi = uv.y * 2.0 * PI;\\n\\\n\t\t\t\t\tfloat cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\\n\\\n\t\t\t\t\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\\n\\\n\t\t\t\t\tvec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\\n\\\n\t\t\t\t\treturn vecSpace * sampleDir;\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\tvec3 ImportanceSampleGGX( vec2 uv, mat3 vecSpace, float Roughness )\\n\\\n\t\t\t\t{\\n\\\n\t\t\t\t\tfloat a = Roughness * Roughness;\\n\\\n\t\t\t\t\tfloat Phi = 2.0 * PI * uv.x;\\n\\\n\t\t\t\t\tfloat CosTheta = sqrt( (1.0 - uv.y) / ( 1.0 + (a*a - 1.0) * uv.y ) );\\n\\\n\t\t\t\t\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\\n\\\n\t\t\t\t\treturn vecSpace * vec3(SinTheta * cos( Phi ), SinTheta * sin( Phi ), CosTheta);\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\tmat3 matrixFromVector(vec3 n) {\\n\\\n\t\t\t\t\tfloat a = 1.0 / (1.0 + n.z);\\n\\\n\t\t\t\t\tfloat b = -n.x * n.y * a;\\n\\\n\t\t\t\t\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\\n\\\n\t\t\t\t\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\\n\\\n\t\t\t\t\treturn mat3(b1, b2, n);\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\t\\n\\\n\t\t\t\tvec4 testColorMap(float Roughness) {\\n\\\n\t\t\t\t\tvec4 color;\\n\\\n\t\t\t\t\tif(faceIndex == 0)\\n\\\n\t\t\t\t\t\tcolor = vec4(1.0,0.0,0.0,1.0);\\n\\\n\t\t\t\t\telse if(faceIndex == 1)\\n\\\n\t\t\t\t\t\tcolor = vec4(0.0,1.0,0.0,1.0);\\n\\\n\t\t\t\t\telse if(faceIndex == 2)\\n\\\n\t\t\t\t\t\tcolor = vec4(0.0,0.0,1.0,1.0);\\n\\\n\t\t\t\t\telse if(faceIndex == 3)\\n\\\n\t\t\t\t\t\tcolor = vec4(1.0,1.0,0.0,1.0);\\n\\\n\t\t\t\t\telse if(faceIndex == 4)\\n\\\n\t\t\t\t\t\tcolor = vec4(0.0,1.0,1.0,1.0);\\n\\\n\t\t\t\t\telse\\n\\\n\t\t\t\t\t\tcolor = vec4(1.0,0.0,1.0,1.0);\\n\\\n\t\t\t\t\tcolor *= ( 1.0 - Roughness );\\n\\\n\t\t\t\t\treturn color;\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec3 sampleDirection;\\n\\\n\t\t\t\t\tvec2 uv = vUv*2.0 - 1.0;\\n\\\n\t\t\t\t\tfloat offset = -1.0/mapSize;\\n\\\n\t\t\t\t\tconst float a = -1.0;\\n\\\n\t\t\t\t\tconst float b = 1.0;\\n\\\n\t\t\t\t\tfloat c = -1.0 + offset;\\n\\\n\t\t\t\t\tfloat d = 1.0 - offset;\\n\\\n\t\t\t\t\tfloat bminusa = b - a;\\n\\\n\t\t\t\t\tuv.x = (uv.x - a)/bminusa * d - (uv.x - b)/bminusa * c;\\n\\\n\t\t\t\t\tuv.y = (uv.y - a)/bminusa * d - (uv.y - b)/bminusa * c;\\n\\\n\t\t\t\t\tif (faceIndex==0) {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(1.0, -uv.y, -uv.x);\\n\\\n\t\t\t\t\t} else if (faceIndex==1) {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(-1.0, -uv.y, uv.x);\\n\\\n\t\t\t\t\t} else if (faceIndex==2) {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(uv.x, 1.0, uv.y);\\n\\\n\t\t\t\t\t} else if (faceIndex==3) {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(uv.x, -1.0, -uv.y);\\n\\\n\t\t\t\t\t} else if (faceIndex==4) {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(uv.x, -uv.y, 1.0);\\n\\\n\t\t\t\t\t} else {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(-uv.x, -uv.y, -1.0);\\n\\\n\t\t\t\t\t}\\n\\\n\t\t\t\t\tvec3 correctedDirection = vec3( tFlip * sampleDirection.x, sampleDirection.yz );\\n\\\n\t\t\t\t\tmat3 vecSpace = matrixFromVector( normalize( correctedDirection ) );\\n\\\n\t\t\t\t\tvec3 rgbColor = vec3(0.0);\\n\\\n\t\t\t\t\tconst int NumSamples = SAMPLES_PER_LEVEL;\\n\\\n\t\t\t\t\tvec3 vect;\\n\\\n\t\t\t\t\tfloat weight = 0.0;\\n\\\n\t\t\t\t\tfor( int i = 0; i < NumSamples; i ++ ) {\\n\\\n\t\t\t\t\t\tfloat sini = sin(float(i));\\n\\\n\t\t\t\t\t\tfloat cosi = cos(float(i));\\n\\\n\t\t\t\t\t\tfloat r = rand(vec2(sini, cosi));\\n\\\n\t\t\t\t\t\tvect = ImportanceSampleGGX(vec2(float(i) / float(NumSamples), r), vecSpace, roughness);\\n\\\n\t\t\t\t\t\tfloat dotProd = dot(vect, normalize(sampleDirection));\\n\\\n\t\t\t\t\t\tweight += dotProd;\\n\\\n\t\t\t\t\t\tvec3 color = envMapTexelToLinear(textureCube(envMap, vect)).rgb;\\n\\\n\t\t\t\t\t\trgbColor.rgb += color;\\n\\\n\t\t\t\t\t}\\n\\\n\t\t\t\t\trgbColor /= float(NumSamples);\\n\\\n\t\t\t\t\t//rgbColor = testColorMap( roughness ).rgb;\\n\\\n\t\t\t\t\tgl_FragColor = linearToOutputTexel( vec4( rgbColor, 1.0 ) );\\n\\\n\t\t\t\t}\",\n      blending: NoBlending\n    });\n    shaderMaterial.type = 'PMREMGenerator';\n    return shaderMaterial;\n  }\n\n  return PMREMGenerator;\n}();\n\nexport { PMREMGenerator };","map":null,"metadata":{},"sourceType":"module"}