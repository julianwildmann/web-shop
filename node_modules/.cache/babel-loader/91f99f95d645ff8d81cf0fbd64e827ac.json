{"ast":null,"code":"/*\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n\nimport { EventDispatcher, Quaternion, Spherical, Vector2, Vector3 } from 'three';\nimport { clamp } from '../utilities.js';\nexport const DEFAULT_OPTIONS = Object.freeze({\n  minimumRadius: 1,\n  maximumRadius: 2,\n  minimumPolarAngle: Math.PI / 8,\n  maximumPolarAngle: Math.PI - Math.PI / 8,\n  minimumAzimuthalAngle: -Infinity,\n  maximumAzimuthalAngle: Infinity,\n  minimumFov: 20,\n  maximumFov: 45,\n  eventHandlingBehavior: 'prevent-all',\n  interactionPolicy: 'allow-when-focused'\n});\nconst $velocity = Symbol('v'); // Internal orbital position state\n\nconst $spherical = Symbol('spherical');\nconst $goalSpherical = Symbol('goalSpherical');\nconst $thetaDamper = Symbol('thetaDamper');\nconst $phiDamper = Symbol('phiDamper');\nconst $radiusDamper = Symbol('radiusDamper');\nconst $fov = Symbol('fov');\nconst $goalFov = Symbol('goalFov');\nconst $fovDamper = Symbol('fovDamper');\nconst $target = Symbol('target');\nconst $options = Symbol('options');\nconst $upQuaternion = Symbol('upQuaternion');\nconst $upQuaternionInverse = Symbol('upQuaternionInverse');\nconst $touchMode = Symbol('touchMode');\nconst $canInteract = Symbol('canInteract');\nconst $interactionEnabled = Symbol('interactionEnabled');\nconst $zoomMeters = Symbol('zoomMeters');\nconst $userAdjustOrbit = Symbol('userAdjustOrbit');\nconst $isUserChange = Symbol('isUserChange');\nconst $isStationary = Symbol('isMoving');\nconst $moveCamera = Symbol('moveCamera'); // Pointer state\n\nconst $pointerIsDown = Symbol('pointerIsDown');\nconst $lastPointerPosition = Symbol('lastPointerPosition');\nconst $lastTouches = Symbol('lastTouches'); // Value conversion methods\n\nconst $pixelLengthToSphericalAngle = Symbol('pixelLengthToSphericalAngle');\nconst $sphericalToPosition = Symbol('sphericalToPosition');\nconst $twoTouchDistance = Symbol('twoTouchDistance'); // Event handlers\n\nconst $onMouseMove = Symbol('onMouseMove');\nconst $onMouseDown = Symbol('onMouseDown');\nconst $onMouseUp = Symbol('onMouseUp');\nconst $onTouchStart = Symbol('onTouchStart');\nconst $onTouchEnd = Symbol('onTouchEnd');\nconst $onTouchMove = Symbol('onTouchMove');\nconst $onWheel = Symbol('onWheel');\nconst $onKeyDown = Symbol('onKeyDown');\nconst $handlePointerMove = Symbol('handlePointerMove');\nconst $handlePointerDown = Symbol('handlePointerDown');\nconst $handlePointerUp = Symbol('handlePointerUp');\nconst $handleWheel = Symbol('handleWheel');\nconst $handleKey = Symbol('handleKey'); // Constants\n\nconst USER_INTERACTION_CHANGE_SOURCE = 'user-interaction';\nconst DEFAULT_INTERACTION_CHANGE_SOURCE = 'none';\nconst TOUCH_EVENT_RE = /^touch(start|end|move)$/;\nconst KEYBOARD_ORBIT_INCREMENT = Math.PI / 8;\nconst DECAY_MILLISECONDS = 50;\nconst NATURAL_FREQUENCY = 1 / DECAY_MILLISECONDS;\nconst NIL_SPEED = 0.0002 * NATURAL_FREQUENCY;\nconst TAU = 2 * Math.PI;\nconst UP = new Vector3(0, 1, 0);\nexport const KeyCode = {\n  PAGE_UP: 33,\n  PAGE_DOWN: 34,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40\n};\n/**\n * The Damper class is a generic second-order critically damped system that does\n * one linear step of the desired length of time. The only parameter is\n * DECAY_MILLISECONDS, which should be adjustable: TODO(#580). This common\n * parameter makes all states converge at the same rate regardless of scale.\n * xNormalization is a number to provide the rough scale of x, such that\n * NIL_SPEED clamping also happens at roughly the same convergence for all\n * states.\n */\n\nexport class Damper {\n  constructor() {\n    this[_a] = 0;\n  }\n\n  update(x, xGoal, timeStepMilliseconds, xNormalization) {\n    if (x == null) {\n      return xGoal;\n    }\n\n    if (timeStepMilliseconds < 0) {\n      return x;\n    } // Exact solution to a critically damped second-order system, where:\n    // acceleration = NATURAL_FREQUENCY * NATURAL_FREQUENCY * (xGoal - x) -\n    // 2 * NATURAL_FREQUENCY * this[$velocity];\n\n\n    const deltaX = x - xGoal;\n    const intermediateVelocity = this[$velocity] + NATURAL_FREQUENCY * deltaX;\n    const intermediateX = deltaX + timeStepMilliseconds * intermediateVelocity;\n    const decay = Math.exp(-NATURAL_FREQUENCY * timeStepMilliseconds);\n    const newVelocity = (intermediateVelocity - NATURAL_FREQUENCY * intermediateX) * decay;\n    const acceleration = -NATURAL_FREQUENCY * (newVelocity + intermediateVelocity * decay);\n\n    if (Math.abs(newVelocity) < NIL_SPEED * xNormalization && acceleration * deltaX >= 0) {\n      // This ensures the controls settle and stop calling this function instead\n      // of asymptotically approaching their goal.\n      this[$velocity] = 0;\n      return xGoal;\n    } else {\n      this[$velocity] = newVelocity;\n      return xGoal + intermediateX * decay;\n    }\n  }\n\n}\n_a = $velocity;\n/**\n * SmoothControls is a Three.js helper for adding delightful pointer and\n * keyboard-based input to a staged Three.js scene. Its API is very similar to\n * OrbitControls, but it offers more opinionated (subjectively more delightful)\n * defaults, easy extensibility and subjectively better out-of-the-box keyboard\n * support.\n *\n * One important change compared to OrbitControls is that the `update` method\n * of SmoothControls must be invoked on every frame, otherwise the controls\n * will not have an effect.\n *\n * Another notable difference compared to OrbitControls is that SmoothControls\n * does not currently support panning (but probably will in a future revision).\n *\n * Like OrbitControls, SmoothControls assumes that the orientation of the camera\n * has been set in terms of position, rotation and scale, so it is important to\n * ensure that the camera's matrixWorld is in sync before using SmoothControls.\n */\n\nexport class SmoothControls extends EventDispatcher {\n  constructor(camera, element) {\n    super();\n    this.camera = camera;\n    this.element = element;\n    this[_b] = false;\n    this[_c] = new Quaternion();\n    this[_d] = new Quaternion();\n    this[_e] = false;\n    this[_f] = new Spherical();\n    this[_g] = new Spherical();\n    this[_h] = new Damper();\n    this[_j] = new Damper();\n    this[_k] = new Damper();\n    this[_l] = new Damper();\n    this[_m] = new Vector3();\n    this[_o] = false;\n    this[_p] = new Vector2();\n    this[_q] = 1;\n    this[$upQuaternion].setFromUnitVectors(camera.up, UP);\n    this[$upQuaternionInverse].copy(this[$upQuaternion]).inverse();\n\n    this[$onMouseMove] = event => this[$handlePointerMove](event);\n\n    this[$onMouseDown] = event => this[$handlePointerDown](event);\n\n    this[$onMouseUp] = event => this[$handlePointerUp](event);\n\n    this[$onWheel] = event => this[$handleWheel](event);\n\n    this[$onKeyDown] = event => this[$handleKey](event);\n\n    this[$onTouchStart] = event => this[$handlePointerDown](event);\n\n    this[$onTouchEnd] = event => this[$handlePointerUp](event);\n\n    this[$onTouchMove] = event => this[$handlePointerMove](event);\n\n    this[$options] = Object.assign({}, DEFAULT_OPTIONS);\n    this.setOrbit(0, Math.PI / 2, 1);\n    this.setFov(100);\n    this.jumpToGoal();\n  }\n\n  get interactionEnabled() {\n    return this[$interactionEnabled];\n  }\n\n  enableInteraction() {\n    if (this[$interactionEnabled] === false) {\n      const element = this.element;\n      element.addEventListener('mousemove', this[$onMouseMove]);\n      element.addEventListener('mousedown', this[$onMouseDown]);\n      element.addEventListener('wheel', this[$onWheel]);\n      element.addEventListener('keydown', this[$onKeyDown]);\n      element.addEventListener('touchstart', this[$onTouchStart]);\n      element.addEventListener('touchmove', this[$onTouchMove]);\n      self.addEventListener('mouseup', this[$onMouseUp]);\n      self.addEventListener('touchend', this[$onTouchEnd]);\n      this.element.style.cursor = 'grab';\n      this[$interactionEnabled] = true;\n    }\n  }\n\n  disableInteraction() {\n    if (this[$interactionEnabled] === true) {\n      const element = this.element;\n      element.removeEventListener('mousemove', this[$onMouseMove]);\n      element.removeEventListener('mousedown', this[$onMouseDown]);\n      element.removeEventListener('wheel', this[$onWheel]);\n      element.removeEventListener('keydown', this[$onKeyDown]);\n      element.removeEventListener('touchstart', this[$onTouchStart]);\n      element.removeEventListener('touchmove', this[$onTouchMove]);\n      self.removeEventListener('mouseup', this[$onMouseUp]);\n      self.removeEventListener('touchend', this[$onTouchEnd]);\n      element.style.cursor = '';\n      this[$interactionEnabled] = false;\n    }\n  }\n  /**\n   * The options that are currently configured for the controls instance.\n   */\n\n\n  get options() {\n    return this[$options];\n  }\n  /**\n   * Copy the spherical values that represent the current camera orbital\n   * position relative to the configured target into a provided Spherical\n   * instance. If no Spherical is provided, a new Spherical will be allocated\n   * to copy the values into. The Spherical that values are copied into is\n   * returned.\n   */\n\n\n  getCameraSpherical(target = new Spherical()) {\n    return target.copy(this[$spherical]);\n  }\n  /**\n   * Returns the camera's current vertical field of view in degrees.\n   */\n\n\n  getFieldOfView() {\n    return this.camera.fov;\n  }\n  /**\n   * Configure the options of the controls. Configured options will be\n   * merged with whatever options have already been configured for this\n   * controls instance.\n   */\n\n\n  applyOptions(options) {\n    Object.assign(this[$options], options); // Re-evaluates clamping based on potentially new values for min/max\n    // polar, azimuth and radius:\n\n    this.setOrbit(); // Prevent interpolation in the case that any target spherical values\n    // changed (preserving OrbitalControls behavior):\n\n    if (this[$isStationary]()) {\n      return;\n    }\n\n    this[$spherical].copy(this[$goalSpherical]);\n    this[$moveCamera]();\n  }\n  /**\n   * Sets the non-interpolated camera parameters\n   */\n\n\n  updateIntrinsics(nearPlane, farPlane, aspect, zoomSensitivity) {\n    this[$zoomMeters] = zoomSensitivity;\n    this.camera.near = nearPlane;\n    this.camera.far = farPlane;\n    this.camera.aspect = aspect;\n    this.camera.updateProjectionMatrix();\n  }\n  /**\n   * Set the absolute orbital goal of the camera. The change will be\n   * applied over a number of frames depending on configured acceleration and\n   * dampening options.\n   *\n   * Returns true if invoking the method will result in the camera changing\n   * position and/or rotation, otherwise false.\n   */\n\n\n  setOrbit(goalTheta = this[$goalSpherical].theta, goalPhi = this[$goalSpherical].phi, goalRadius = this[$goalSpherical].radius) {\n    const _this$$options = this[$options],\n          minimumAzimuthalAngle = _this$$options.minimumAzimuthalAngle,\n          maximumAzimuthalAngle = _this$$options.maximumAzimuthalAngle,\n          minimumPolarAngle = _this$$options.minimumPolarAngle,\n          maximumPolarAngle = _this$$options.maximumPolarAngle,\n          minimumRadius = _this$$options.minimumRadius,\n          maximumRadius = _this$$options.maximumRadius;\n    const _this$$goalSpherical = this[$goalSpherical],\n          theta = _this$$goalSpherical.theta,\n          phi = _this$$goalSpherical.phi,\n          radius = _this$$goalSpherical.radius;\n    const nextTheta = clamp(goalTheta, minimumAzimuthalAngle, maximumAzimuthalAngle);\n    const nextPhi = clamp(goalPhi, minimumPolarAngle, maximumPolarAngle);\n    const nextRadius = clamp(goalRadius, minimumRadius, maximumRadius);\n\n    if (nextTheta === theta && nextPhi === phi && nextRadius === radius) {\n      return false;\n    }\n\n    this[$goalSpherical].theta = nextTheta;\n    this[$goalSpherical].phi = nextPhi;\n    this[$goalSpherical].radius = nextRadius;\n    this[$goalSpherical].makeSafe();\n    this[$isUserChange] = false;\n    return true;\n  }\n  /**\n   * Subset of setOrbit() above, which only sets the camera's radius.\n   */\n\n\n  setRadius(radius) {\n    this[$goalSpherical].radius = radius;\n    this.setOrbit();\n  }\n  /**\n   * Sets the goal field of view for the camera\n   */\n\n\n  setFov(fov) {\n    const _this$$options2 = this[$options],\n          minimumFov = _this$$options2.minimumFov,\n          maximumFov = _this$$options2.maximumFov;\n    this[$goalFov] = clamp(fov, minimumFov, maximumFov);\n  }\n  /**\n   * Sets the target the camera is pointing toward\n   */\n\n\n  setTarget(target) {\n    if (!this[$target].equals(target)) {\n      this[$target].copy(target);\n      this[$moveCamera]();\n    }\n  }\n  /**\n   * Returns a copy of the target position the camera is pointed toward\n   */\n\n\n  getTarget() {\n    return this[$target].clone();\n  }\n  /**\n   * Adjust the orbital position of the camera relative to its current orbital\n   * position.\n   */\n\n\n  adjustOrbit(deltaTheta, deltaPhi, deltaRadius) {\n    const _this$$goalSpherical2 = this[$goalSpherical],\n          theta = _this$$goalSpherical2.theta,\n          phi = _this$$goalSpherical2.phi,\n          radius = _this$$goalSpherical2.radius;\n    const goalTheta = theta - deltaTheta;\n    const goalPhi = phi - deltaPhi;\n    const goalRadius = radius + deltaRadius;\n    return this.setOrbit(goalTheta, goalPhi, goalRadius);\n  }\n  /**\n   * Move the camera instantly instead of accelerating toward the goal\n   * parameters.\n   */\n\n\n  jumpToGoal() {\n    this.update(0, 100 * DECAY_MILLISECONDS);\n  }\n  /**\n   * Update controls. In most cases, this will result in the camera\n   * interpolating its position and rotation until it lines up with the\n   * designated goal orbital position.\n   *\n   * Time and delta are measured in milliseconds.\n   */\n\n\n  update(_time, delta) {\n    if (this[$isStationary]()) {\n      return;\n    }\n\n    const _this$$options3 = this[$options],\n          maximumPolarAngle = _this$$options3.maximumPolarAngle,\n          maximumRadius = _this$$options3.maximumRadius,\n          maximumFov = _this$$options3.maximumFov;\n    this[$spherical].theta = this[$thetaDamper].update(this[$spherical].theta, this[$goalSpherical].theta, delta, Math.PI);\n    this[$spherical].phi = this[$phiDamper].update(this[$spherical].phi, this[$goalSpherical].phi, delta, maximumPolarAngle);\n    this[$spherical].radius = this[$radiusDamper].update(this[$spherical].radius, this[$goalSpherical].radius, delta, maximumRadius);\n    this[$fov] = this[$fovDamper].update(this[$fov], this[$goalFov], delta, maximumFov);\n    this[$moveCamera]();\n  }\n\n  [(_b = $interactionEnabled, _c = $upQuaternion, _d = $upQuaternionInverse, _e = $isUserChange, _f = $spherical, _g = $goalSpherical, _h = $thetaDamper, _j = $phiDamper, _k = $radiusDamper, _l = $fovDamper, _m = $target, _o = $pointerIsDown, _p = $lastPointerPosition, _q = $zoomMeters, $isStationary)]() {\n    return this[$goalSpherical].theta === this[$spherical].theta && this[$goalSpherical].phi === this[$spherical].phi && this[$goalSpherical].radius === this[$spherical].radius && this[$goalFov] === this[$fov];\n  }\n\n  [$moveCamera]() {\n    // Derive the new camera position from the updated spherical:\n    this[$spherical].makeSafe();\n    this[$sphericalToPosition](this[$spherical], this.camera.position);\n    this.camera.lookAt(this[$target]);\n\n    if (this.camera.fov !== this[$fov]) {\n      this.camera.fov = this[$fov];\n      this.camera.updateProjectionMatrix();\n    }\n\n    const source = this[$isUserChange] ? USER_INTERACTION_CHANGE_SOURCE : DEFAULT_INTERACTION_CHANGE_SOURCE;\n    this.dispatchEvent({\n      type: 'change',\n      source\n    });\n  }\n\n  get [$canInteract]() {\n    if (this[$options].interactionPolicy == 'allow-when-focused') {\n      const rootNode = this.element.getRootNode();\n      return rootNode.activeElement === this.element;\n    }\n\n    return this[$options].interactionPolicy === 'always-allow';\n  }\n\n  [$userAdjustOrbit](deltaTheta, deltaPhi, deltaRadius) {\n    const handled = this.adjustOrbit(deltaTheta, deltaPhi, deltaRadius);\n    this[$isUserChange] = true;\n    return handled;\n  }\n\n  [$pixelLengthToSphericalAngle](pixelLength) {\n    return TAU * pixelLength / this.element.clientHeight;\n  }\n\n  [$sphericalToPosition](spherical, position) {\n    position.setFromSpherical(spherical);\n    position.applyQuaternion(this[$upQuaternionInverse]);\n    position.add(this[$target]);\n  }\n\n  [$twoTouchDistance](touchOne, touchTwo) {\n    const xOne = touchOne.clientX,\n          yOne = touchOne.clientY;\n    const xTwo = touchTwo.clientX,\n          yTwo = touchTwo.clientY;\n    const xDelta = xTwo - xOne;\n    const yDelta = yTwo - yOne;\n    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);\n  }\n\n  [$handlePointerMove](event) {\n    if (!this[$pointerIsDown] || !this[$canInteract]) {\n      return;\n    }\n\n    let handled = false; // NOTE(cdata): We test event.type as some browsers do not have a global\n    // TouchEvent contructor.\n\n    if (TOUCH_EVENT_RE.test(event.type)) {\n      const touches = event.touches;\n\n      switch (this[$touchMode]) {\n        case 'zoom':\n          if (this[$lastTouches].length > 1 && touches.length > 1) {\n            const lastTouchDistance = this[$twoTouchDistance](this[$lastTouches][0], this[$lastTouches][1]);\n            const touchDistance = this[$twoTouchDistance](touches[0], touches[1]);\n            const radiusDelta = -1 * this[$zoomMeters] * (touchDistance - lastTouchDistance) / 10.0;\n            handled = this[$userAdjustOrbit](0, 0, radiusDelta);\n          }\n\n          break;\n\n        case 'rotate':\n          const _this$$lastTouches$ = this[$lastTouches][0],\n                xOne = _this$$lastTouches$.clientX,\n                yOne = _this$$lastTouches$.clientY;\n          const _touches$ = touches[0],\n                xTwo = _touches$.clientX,\n                yTwo = _touches$.clientY;\n          const deltaTheta = this[$pixelLengthToSphericalAngle](xTwo - xOne);\n          const deltaPhi = this[$pixelLengthToSphericalAngle](yTwo - yOne);\n          handled = this[$userAdjustOrbit](deltaTheta, deltaPhi, 0);\n          break;\n      }\n\n      this[$lastTouches] = touches;\n    } else {\n      const x = event.clientX,\n            y = event.clientY;\n      const deltaTheta = this[$pixelLengthToSphericalAngle](x - this[$lastPointerPosition].x);\n      const deltaPhi = this[$pixelLengthToSphericalAngle](y - this[$lastPointerPosition].y);\n      handled = this[$userAdjustOrbit](deltaTheta, deltaPhi, 0.0);\n      this[$lastPointerPosition].set(x, y);\n    }\n\n    if ((handled || this[$options].eventHandlingBehavior === 'prevent-all') && event.cancelable) {\n      event.preventDefault();\n    }\n\n    ;\n  }\n\n  [$handlePointerDown](event) {\n    this[$pointerIsDown] = true;\n\n    if (TOUCH_EVENT_RE.test(event.type)) {\n      const touches = event.touches;\n\n      switch (touches.length) {\n        default:\n        case 1:\n          this[$touchMode] = 'rotate';\n          break;\n\n        case 2:\n          this[$touchMode] = 'zoom';\n          break;\n      }\n\n      this[$lastTouches] = touches;\n    } else {\n      const x = event.clientX,\n            y = event.clientY;\n      this[$lastPointerPosition].set(x, y);\n      this.element.style.cursor = 'grabbing';\n    }\n  }\n\n  [$handlePointerUp](_event) {\n    this.element.style.cursor = 'grab';\n    this[$pointerIsDown] = false;\n  }\n\n  [$handleWheel](event) {\n    if (!this[$canInteract]) {\n      return;\n    }\n\n    const deltaRadius = event.deltaY * this[$zoomMeters] / 10.0;\n\n    if ((this[$userAdjustOrbit](0, 0, deltaRadius) || this[$options].eventHandlingBehavior === 'prevent-all') && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n\n  [$handleKey](event) {\n    // We track if the key is actually one we respond to, so as not to\n    // accidentally clober unrelated key inputs when the <model-viewer> has\n    // focus and eventHandlingBehavior is set to 'prevent-all'.\n    let relevantKey = false;\n    let handled = false;\n\n    switch (event.keyCode) {\n      case KeyCode.PAGE_UP:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](0, 0, this[$zoomMeters]);\n        break;\n\n      case KeyCode.PAGE_DOWN:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](0, 0, -1 * this[$zoomMeters]);\n        break;\n\n      case KeyCode.UP:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](0, -KEYBOARD_ORBIT_INCREMENT, 0);\n        break;\n\n      case KeyCode.DOWN:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](0, KEYBOARD_ORBIT_INCREMENT, 0);\n        break;\n\n      case KeyCode.LEFT:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](-KEYBOARD_ORBIT_INCREMENT, 0, 0);\n        break;\n\n      case KeyCode.RIGHT:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](KEYBOARD_ORBIT_INCREMENT, 0, 0);\n        break;\n    }\n\n    if (relevantKey && (handled || this[$options].eventHandlingBehavior === 'prevent-all') && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}