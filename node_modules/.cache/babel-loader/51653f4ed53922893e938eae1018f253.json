{"ast":null,"code":"/**\n* @author Richard M. / https://github.com/richardmonette\n* @author WestLangley / http://github.com/WestLangley\n*/\nimport * as ThreeModule from 'three';\nconst THREE = Object.assign({}, ThreeModule);\nexport const CubemapGenerator = THREE.CubemapGenerator = function (renderer) {\n  this.renderer = renderer;\n};\n\nTHREE.CubemapGenerator.prototype.fromEquirectangular = function (texture, options) {\n  options = options || {};\n  var scene = new THREE.Scene();\n  var shader = {\n    uniforms: {\n      tEquirect: {\n        value: null\n      }\n    },\n    vertexShader: \"\\n\\t\\t\\tvarying vec3 vWorldDirection;\\n\\n\\t\\t\\t//include <common>\\n\\t\\t\\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\n\\t\\t\\t\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\n\\t\\t\\t\\t#include <begin_vertex>\\n\\t\\t\\t\\t#include <project_vertex>\\n\\n\\t\\t\\t}\\n\\t\\t\\t\",\n    fragmentShader: \"\\n\\t\\t\\tuniform sampler2D tEquirect;\\n\\n\\t\\t\\tvarying vec3 vWorldDirection;\\n\\n\\t\\t\\t//include <common>\\n\\t\\t\\t#define RECIPROCAL_PI 0.31830988618\\n\\t\\t\\t#define RECIPROCAL_PI2 0.15915494\\n\\n\\t\\t\\tvoid main() {\\n\\n\\t\\t\\t\\tvec3 direction = normalize( vWorldDirection );\\n\\n\\t\\t\\t\\tvec2 sampleUV;\\n\\n\\t\\t\\t\\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\n\\t\\t\\t\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\n\\t\\t\\t\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\\n\\t\\t\\t}\\n\\t\\t\\t\"\n  };\n  var material = new THREE.ShaderMaterial({\n    type: 'CubemapFromEquirect',\n    uniforms: THREE.UniformsUtils.clone(shader.uniforms),\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader,\n    side: THREE.BackSide,\n    blending: THREE.NoBlending\n  });\n  material.uniforms.tEquirect.value = texture;\n  var mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(5, 5, 5), material);\n  scene.add(mesh);\n  var resolution = options.resolution || 512;\n  var params = {\n    type: texture.type,\n    format: texture.format,\n    encoding: texture.encoding,\n    generateMipmaps: options.generateMipmaps !== undefined ? options.generateMipmaps : texture.generateMipmaps,\n    minFilter: options.minFilter !== undefined ? options.minFilter : texture.minFilter,\n    magFilter: options.magFilter !== undefined ? options.magFilter : texture.magFilter\n  };\n  var camera = new THREE.CubeCamera(1, 10, resolution, params);\n  camera.update(this.renderer, scene);\n  mesh.geometry.dispose();\n  mesh.material.dispose();\n  return camera.renderTarget;\n}; //\n\n\nexport const EquirectangularToCubeGenerator = THREE.EquirectangularToCubeGenerator = function () {\n  var camera = new THREE.PerspectiveCamera(90, 1, 0.1, 10);\n  var scene = new THREE.Scene();\n  var boxMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 1, 1), getShader());\n  boxMesh.material.side = THREE.BackSide;\n  scene.add(boxMesh);\n\n  var EquirectangularToCubeGenerator = function (sourceTexture, options) {\n    options = options || {};\n    this.sourceTexture = sourceTexture;\n    this.resolution = options.resolution || 512;\n    this.views = [{\n      t: [1, 0, 0],\n      u: [0, -1, 0]\n    }, {\n      t: [-1, 0, 0],\n      u: [0, -1, 0]\n    }, {\n      t: [0, 1, 0],\n      u: [0, 0, 1]\n    }, {\n      t: [0, -1, 0],\n      u: [0, 0, -1]\n    }, {\n      t: [0, 0, 1],\n      u: [0, -1, 0]\n    }, {\n      t: [0, 0, -1],\n      u: [0, -1, 0]\n    }];\n    var params = {\n      format: options.format || this.sourceTexture.format,\n      magFilter: this.sourceTexture.magFilter,\n      minFilter: this.sourceTexture.minFilter,\n      type: options.type || this.sourceTexture.type,\n      generateMipmaps: this.sourceTexture.generateMipmaps,\n      anisotropy: this.sourceTexture.anisotropy,\n      encoding: this.sourceTexture.encoding\n    };\n    this.renderTarget = new THREE.WebGLRenderTargetCube(this.resolution, this.resolution, params);\n  };\n\n  EquirectangularToCubeGenerator.prototype = {\n    constructor: EquirectangularToCubeGenerator,\n    update: function (renderer) {\n      var currentRenderTarget = renderer.getRenderTarget();\n      boxMesh.material.uniforms.equirectangularMap.value = this.sourceTexture;\n\n      for (var i = 0; i < 6; i++) {\n        var v = this.views[i];\n        camera.position.set(0, 0, 0);\n        camera.up.set(v.u[0], v.u[1], v.u[2]);\n        camera.lookAt(v.t[0], v.t[1], v.t[2]);\n        renderer.setRenderTarget(this.renderTarget, i);\n        renderer.clear();\n        renderer.render(scene, camera);\n      }\n\n      renderer.setRenderTarget(currentRenderTarget);\n      return this.renderTarget.texture;\n    },\n    dispose: function () {\n      this.renderTarget.dispose();\n    }\n  };\n\n  function getShader() {\n    var shaderMaterial = new THREE.ShaderMaterial({\n      uniforms: {\n        \"equirectangularMap\": {\n          value: null\n        }\n      },\n      vertexShader: \"varying vec3 localPosition;\\n\\\n        \\n\\\n        void main() {\\n\\\n          localPosition = position;\\n\\\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n        }\",\n      fragmentShader: \"#include <common>\\n\\\n        varying vec3 localPosition;\\n\\\n        uniform sampler2D equirectangularMap;\\n\\\n        \\n\\\n        vec2 EquirectangularSampleUV(vec3 v) {\\n\\\n          vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\\n\\\n          uv *= vec2(0.1591, 0.3183); // inverse atan\\n\\\n          uv += 0.5;\\n\\\n          return uv;\\n\\\n        }\\n\\\n        \\n\\\n        void main() {\\n\\\n          vec2 uv = EquirectangularSampleUV(normalize(localPosition));\\n\\\n          gl_FragColor = texture2D(equirectangularMap, uv);\\n\\\n        }\",\n      blending: THREE.NoBlending\n    });\n    shaderMaterial.type = 'EquirectangularToCubeGenerator';\n    return shaderMaterial;\n  }\n\n  return EquirectangularToCubeGenerator;\n}();","map":null,"metadata":{},"sourceType":"module"}